<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>HOKUBE GEMINI SOUND LAB</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@300;400;500;700&family=Rajdhani:wght@300;400;500&display=swap');

:root {
  --bg0:        #050810;
  --bg1:        #080d1a;
  --bg2:        #0c1224;
  --panel:      rgba(12, 22, 45, 0.72);
  --glass:      rgba(255,255,255,0.04);
  --glass-hi:   rgba(255,255,255,0.10);
  --border:     rgba(100,200,255,0.12);
  --border-hi:  rgba(100,200,255,0.35);
  --cyan:       #00d4ff;
  --cyan-dim:   rgba(0,212,255,0.18);
  --cyan-glow:  rgba(0,212,255,0.55);
  --ice:        #a8e6f0;
  --white:      #e8f4ff;
  --muted:      rgba(168,230,240,0.4);
  --key-white:  #d0e8f5;
  --key-black:  #0a1520;
  --active-key: #00d4ff;
  --knob-base:  #0e1f35;
  --knob-ring:  #1a3550;
  --knob-hi:    rgba(0,212,255,0.7);
  --font-main:  'Orbitron', monospace;
  --font-body:  'Rajdhani', sans-serif;
  --shadow-deep: 0 8px 32px rgba(0,0,0,0.7);
  --shadow-glow: 0 0 20px rgba(0,212,255,0.25);
}

* { margin:0; padding:0; box-sizing:border-box; }

html, body {
  width: 100%; height: 100%;
  background: var(--bg0);
  color: var(--white);
  font-family: var(--font-body);
  overflow-x: hidden;
  overflow-y: auto;
}

/* ── AMBIENT BG ── */
body::before {
  content:'';
  position:fixed; inset:0;
  background:
    radial-gradient(ellipse 60% 50% at 30% 20%, rgba(0,100,180,0.12) 0%, transparent 60%),
    radial-gradient(ellipse 50% 60% at 75% 80%, rgba(0,180,220,0.08) 0%, transparent 55%),
    radial-gradient(ellipse 80% 80% at 50% 50%, rgba(5,15,40,0.9) 0%, transparent 100%);
  pointer-events:none; z-index:0;
}

/* Subtle grid */
body::after {
  content:'';
  position:fixed; inset:0;
  background-image:
    linear-gradient(rgba(0,212,255,0.025) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0,212,255,0.025) 1px, transparent 1px);
  background-size: 40px 40px;
  pointer-events:none; z-index:0;
}

/* ── LAYOUT ── */
.app {
  position:relative; z-index:1;
  max-width: 1100px;
  margin: 0 auto;
  padding: 1.5rem 1rem 2rem;
  display: flex;
  flex-direction: column;
  gap: 1.2rem;
}

/* ── HEADER ── */
.header {
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding: 0.6rem 1.2rem;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  backdrop-filter: blur(12px);
  box-shadow: var(--shadow-deep), inset 0 1px 0 var(--glass-hi);
}

.logo {
  display:flex; flex-direction:column; gap:1px;
}

.logo-main {
  font-family: var(--font-main);
  font-size: clamp(0.9rem, 2.5vw, 1.3rem);
  font-weight: 700;
  letter-spacing: 0.25em;
  color: var(--cyan);
  text-shadow: 0 0 20px var(--cyan-glow), 0 0 40px rgba(0,212,255,0.3);
}

.logo-sub {
  font-size: 0.65rem;
  letter-spacing: 0.3em;
  color: var(--muted);
  font-family: var(--font-main);
  font-weight: 300;
}

.header-indicators {
  display:flex; gap:0.8rem; align-items:center;
}

.led {
  width: 7px; height: 7px;
  border-radius: 50%;
  background: var(--cyan);
  box-shadow: 0 0 6px var(--cyan), 0 0 12px var(--cyan-glow);
  animation: ledPulse 2.4s ease-in-out infinite;
}
.led.red { background:#ff4466; box-shadow:0 0 6px #ff4466, 0 0 12px rgba(255,68,102,0.5); animation-delay:0.8s; }
.led.green { background:#44ffaa; box-shadow:0 0 6px #44ffaa, 0 0 12px rgba(68,255,170,0.5); animation-delay:1.6s; }

@keyframes ledPulse {
  0%,100% { opacity:1; } 50% { opacity:0.4; }
}

.polyphony-display {
  font-family: var(--font-main);
  font-size: 0.6rem;
  color: var(--muted);
  letter-spacing:0.15em;
  text-align:right;
}
#voiceCount { color: var(--cyan); }

/* ── MAIN SYNTH PANEL ── */
.synth-panel {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 1rem;
}

/* ── SECTION CARDS ── */
.section {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 1rem 0.9rem 1.1rem;
  backdrop-filter: blur(16px);
  box-shadow: var(--shadow-deep), inset 0 1px 0 var(--glass-hi);
  position: relative;
  overflow: hidden;
}

.section::before {
  content:'';
  position:absolute; top:0; left:0; right:0; height:1px;
  background: linear-gradient(90deg, transparent, var(--cyan-dim), transparent);
}

.section-title {
  font-family: var(--font-main);
  font-size: 0.5rem;
  letter-spacing: 0.3em;
  color: var(--muted);
  text-transform: uppercase;
  margin-bottom: 1rem;
  display:flex; align-items:center; gap:0.5rem;
}
.section-title::after {
  content:''; flex:1; height:1px;
  background: linear-gradient(90deg, var(--border), transparent);
}

.knobs-row {
  display: flex;
  justify-content: space-around;
  align-items: flex-end;
  gap: 0.3rem;
  flex-wrap: wrap;
}

/* ── KNOB ── */
.knob-wrap {
  display:flex; flex-direction:column; align-items:center; gap:0.35rem;
  cursor: pointer;
}

.knob-outer {
  position:relative;
  width: 52px; height: 52px;
  border-radius: 50%;
  background: radial-gradient(circle at 35% 30%, #1e3a5a, var(--knob-base));
  border: 2px solid var(--knob-ring);
  box-shadow:
    0 4px 12px rgba(0,0,0,0.6),
    inset 0 1px 2px rgba(255,255,255,0.08),
    0 0 0 1px rgba(0,0,0,0.4);
  transition: box-shadow 0.15s;
}

.knob-outer:hover {
  box-shadow:
    0 4px 12px rgba(0,0,0,0.6),
    inset 0 1px 2px rgba(255,255,255,0.08),
    0 0 0 1px rgba(0,0,0,0.4),
    0 0 16px var(--cyan-dim);
}

.knob-outer.active {
  box-shadow:
    0 4px 12px rgba(0,0,0,0.6),
    inset 0 1px 2px rgba(255,255,255,0.08),
    0 0 0 1px var(--border-hi),
    0 0 20px var(--cyan-glow);
}

/* SVG ring track */
.knob-svg {
  position:absolute; inset:-6px;
  width: calc(100% + 12px); height: calc(100% + 12px);
  pointer-events:none;
}

.knob-track { stroke: rgba(0,212,255,0.1); fill:none; }
.knob-fill  { stroke: var(--cyan); fill:none; stroke-linecap:round;
              filter: drop-shadow(0 0 3px var(--cyan)); transition: stroke-dashoffset 0.05s; }

/* Indicator dot */
.knob-dot {
  position:absolute;
  width:4px; height:14px;
  background: linear-gradient(to bottom, var(--cyan), rgba(0,212,255,0.3));
  border-radius:2px;
  top:5px; left:50%; transform-origin: bottom center;
  margin-left:-2px;
  box-shadow: 0 0 6px var(--cyan);
  pointer-events:none;
}

.knob-label {
  font-family: var(--font-main);
  font-size: 0.42rem;
  letter-spacing: 0.15em;
  color: var(--muted);
  text-transform: uppercase;
  text-align:center;
}

.knob-value {
  font-family: var(--font-main);
  font-size: 0.45rem;
  color: var(--cyan);
  letter-spacing:0.1em;
}

/* ── SWITCH / TOGGLE ── */
.switch-row {
  display:flex; gap:0.5rem; justify-content:center; flex-wrap:wrap;
  margin-top:0.6rem;
}

.synth-switch {
  background: var(--knob-base);
  border: 1px solid var(--border);
  border-radius:4px;
  color: var(--muted);
  font-family: var(--font-main);
  font-size: 0.42rem;
  letter-spacing:0.15em;
  padding: 0.3rem 0.6rem;
  cursor:pointer;
  transition: all 0.15s;
  text-transform:uppercase;
}

.synth-switch.on {
  background: var(--cyan-dim);
  border-color: var(--border-hi);
  color: var(--cyan);
  box-shadow: 0 0 10px var(--cyan-dim);
}

/* ── OSCILLOSCOPE ── */
.scope-section {
  grid-column: span 1;
  display:flex; flex-direction:column; gap:0.6rem;
}

.scope-wrap {
  position:relative;
  background: #010a0f;
  border: 1px solid var(--border);
  border-radius:8px;
  overflow:hidden;
  box-shadow: inset 0 0 30px rgba(0,212,255,0.05), var(--shadow-deep);
}

.scope-wrap::before {
  content:'';
  position:absolute; inset:0;
  background:
    linear-gradient(rgba(0,212,255,0.015) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0,212,255,0.015) 1px, transparent 1px);
  background-size: 20px 20px;
  pointer-events:none; z-index:1;
}

/* CRT scanlines */
.scope-wrap::after {
  content:'';
  position:absolute; inset:0;
  background: repeating-linear-gradient(
    0deg, transparent, transparent 2px,
    rgba(0,0,0,0.08) 2px, rgba(0,0,0,0.08) 4px
  );
  pointer-events:none; z-index:2;
}

#oscilloscope {
  display:block;
  width:100%; height:80px;
  position:relative; z-index:0;
}

.scope-labels {
  position:absolute; inset:0;
  display:flex; align-items:flex-start; justify-content:space-between;
  padding:0.4rem 0.6rem;
  pointer-events:none; z-index:3;
}

.scope-label {
  font-family: var(--font-main);
  font-size:0.38rem;
  color: rgba(0,212,255,0.4);
  letter-spacing:0.2em;
}

/* ── KEYBOARD ── */
.keyboard-section {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 1rem;
  backdrop-filter: blur(16px);
  box-shadow: var(--shadow-deep), inset 0 1px 0 var(--glass-hi);
  position:relative; overflow:hidden;
}

.keyboard-section::before {
  content:'';
  position:absolute; top:0; left:0; right:0; height:1px;
  background: linear-gradient(90deg, transparent, var(--cyan-dim), transparent);
}

.keyboard-header {
  display:flex; align-items:center; justify-content:space-between;
  margin-bottom:0.8rem;
}

.keyboard-wrap {
  position:relative;
  height: 88px;
  display:flex;
  user-select:none;
  -webkit-tap-highlight-color: transparent;
}

.key {
  position:relative;
  cursor:pointer;
  border-radius: 0 0 5px 5px;
  transition: background 0.05s, box-shadow 0.05s;
}

.key.white {
  background: linear-gradient(180deg, #b8d8ee 0%, var(--key-white) 60%, #a0c0d8 100%);
  border: 1px solid rgba(0,100,150,0.3);
  border-top: none;
  width: 36px;
  height: 88px;
  z-index:1;
  box-shadow: 0 3px 6px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.5);
  flex-shrink:0;
}

.key.black {
  background: linear-gradient(180deg, #0d1e30 0%, var(--key-black) 40%, #151f2e 100%);
  border: 1px solid rgba(0,150,200,0.2);
  border-top: 2px solid rgba(0,200,255,0.15);
  width: 24px;
  height: 54px;
  z-index:2;
  margin-left:-12px;
  margin-right:-12px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.06);
}

.key.white.active, .key.white:active {
  background: linear-gradient(180deg, var(--cyan) 0%, rgba(0,180,220,0.7) 30%, #70d0e8 100%);
  box-shadow: 0 0 15px var(--cyan-glow), inset 0 1px 0 rgba(255,255,255,0.3);
}

.key.black.active, .key.black:active {
  background: linear-gradient(180deg, var(--cyan) 0%, rgba(0,100,150,0.9) 60%);
  box-shadow: 0 0 12px var(--cyan-glow), inset 0 1px 0 rgba(255,255,255,0.2);
}

.key-hint {
  position:absolute;
  bottom:5px; left:50%; transform:translateX(-50%);
  font-family: var(--font-main);
  font-size:0.38rem;
  color: rgba(0,80,120,0.7);
  pointer-events:none;
  letter-spacing:0.05em;
}

.key.black .key-hint { color: rgba(0,200,255,0.35); bottom:3px; }

/* ── PITCH BEND & MOD ── */
.benders {
  display:flex; flex-direction:column; gap:0.5rem;
  margin-right:0.8rem;
}

.bender-wrap {
  display:flex; flex-direction:column; align-items:center; gap:0.2rem;
}

.bender {
  width:28px; height:70px;
  background: var(--knob-base);
  border:1px solid var(--border);
  border-radius:4px;
  position:relative;
  cursor:ns-resize;
  overflow:hidden;
}

.bender-fill {
  position:absolute; bottom:0; left:0; right:0;
  background: linear-gradient(to top, var(--cyan), transparent);
  opacity:0.4;
  transition:height 0.05s;
}

.bender-thumb {
  position:absolute; left:2px; right:2px;
  height:10px;
  background: linear-gradient(180deg, rgba(255,255,255,0.15), var(--knob-ring));
  border:1px solid var(--border-hi);
  border-radius:2px;
  box-shadow:0 0 6px var(--cyan-dim);
  transition:bottom 0.05s;
}

.bender-label {
  font-family:var(--font-main); font-size:0.35rem;
  color:var(--muted); letter-spacing:0.15em; text-transform:uppercase;
}

/* ── ARPEGGIATOR ── */
.arp-section {
  display:flex; gap:0.4rem; align-items:center;
  padding: 0.4rem 0.5rem;
  background: var(--knob-base);
  border:1px solid var(--border);
  border-radius:6px;
  flex-wrap: wrap;
}

.arp-label {
  font-family:var(--font-main); font-size:0.42rem;
  color:var(--muted); letter-spacing:0.2em;
  white-space:nowrap;
}

.arp-steps {
  display:flex; gap:2px;
}

.arp-step {
  width:8px; height:8px;
  border-radius:2px;
  background: var(--knob-ring);
  border:1px solid var(--border);
  transition:all 0.1s;
}

.arp-step.active {
  background: var(--cyan);
  box-shadow:0 0 6px var(--cyan);
}

/* ── PRESET BAR ── */
.preset-bar {
  display:flex; gap:0.5rem; align-items:center;
  padding:0.5rem 0.8rem;
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:8px;
  backdrop-filter:blur(10px);
  flex-wrap:wrap;
}

.preset-label {
  font-family:var(--font-main); font-size:0.45rem;
  color:var(--muted); letter-spacing:0.2em; margin-right:0.3rem;
}

.preset-btn {
  background:var(--knob-base);
  border:1px solid var(--border);
  border-radius:4px;
  color:var(--muted);
  font-family:var(--font-main); font-size:0.4rem;
  letter-spacing:0.12em;
  padding:0.3rem 0.7rem;
  cursor:pointer;
  transition:all 0.15s;
  text-transform:uppercase;
}

.preset-btn:hover, .preset-btn.selected {
  background:var(--cyan-dim);
  border-color:var(--border-hi);
  color:var(--cyan);
  box-shadow:0 0 8px var(--cyan-dim);
}

/* ════════════════════════════════════════════════════════
   DRUM MACHINE
════════════════════════════════════════════════════════ */
.drum-machine {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 1rem 1.1rem 1.1rem;
  backdrop-filter: blur(16px);
  box-shadow: var(--shadow-deep), inset 0 1px 0 var(--glass-hi);
  position: relative;
  overflow: hidden;
}

.drum-machine::before {
  content:'';
  position:absolute; top:0; left:0; right:0; height:1px;
  background: linear-gradient(90deg, transparent, rgba(255,80,80,0.4), var(--cyan-dim), transparent);
}

.drum-header {
  display:flex; align-items:center; justify-content:space-between;
  margin-bottom: 0.9rem;
  flex-wrap: wrap;
  gap: 0.6rem;
}

.drum-title-block { display:flex; align-items:center; gap:0.8rem; }

.drum-title {
  font-family: var(--font-main);
  font-size: 0.5rem;
  letter-spacing: 0.3em;
  color: var(--muted);
  text-transform: uppercase;
}

.drum-controls { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; }

/* TRAP button — special red/orange glow */
.trap-btn {
  background: rgba(255,60,30,0.1);
  border: 1px solid rgba(255,80,30,0.3);
  border-radius: 5px;
  color: rgba(255,120,80,0.7);
  font-family: var(--font-main);
  font-size: 0.45rem;
  letter-spacing: 0.25em;
  padding: 0.35rem 0.9rem;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
}

.trap-btn::before {
  content:'';
  position:absolute; inset:0;
  background: radial-gradient(ellipse at 50% 120%, rgba(255,80,20,0.3), transparent 70%);
  opacity:0; transition: opacity 0.2s;
}

.trap-btn.on {
  background: rgba(255,60,20,0.25);
  border-color: rgba(255,100,40,0.8);
  color: #ff7040;
  box-shadow: 0 0 16px rgba(255,80,20,0.5), inset 0 0 10px rgba(255,60,20,0.15);
  text-shadow: 0 0 10px rgba(255,100,40,0.8);
}
.trap-btn.on::before { opacity:1; }

/* Play / Stop */
.drum-play-btn {
  width: 28px; height: 28px;
  border-radius: 50%;
  background: var(--knob-base);
  border: 1px solid var(--border-hi);
  color: var(--cyan);
  font-size: 0.6rem;
  cursor: pointer;
  display:flex; align-items:center; justify-content:center;
  transition: all 0.15s;
  box-shadow: 0 0 8px var(--cyan-dim);
}
.drum-play-btn:hover { background: var(--cyan-dim); box-shadow: 0 0 16px var(--cyan-glow); }
.drum-play-btn.playing { background: var(--cyan-dim); border-color: var(--cyan); }

/* BPM display */
.drum-bpm-wrap {
  display:flex; align-items:center; gap:0.4rem;
}
.drum-bpm-label {
  font-family:var(--font-main); font-size:0.4rem; color:var(--muted); letter-spacing:0.15em;
}
.drum-bpm-val {
  font-family:var(--font-main); font-size:0.65rem; color:var(--cyan);
  letter-spacing:0.1em; min-width:2.2rem; text-align:center;
}
.bpm-arrow {
  background:none; border:none; color:var(--muted); cursor:pointer;
  font-size:0.7rem; padding:0 0.1rem; line-height:1;
  transition:color 0.1s;
}
.bpm-arrow:hover { color:var(--cyan); }

/* ── GRID ── */
.drum-grid { display:flex; flex-direction:column; gap:0.35rem; }

.drum-row { display:flex; align-items:center; gap:0.4rem; }

.drum-row-label {
  font-family: var(--font-main);
  font-size: 0.38rem;
  letter-spacing: 0.12em;
  color: var(--muted);
  text-transform: uppercase;
  width: 42px;
  flex-shrink: 0;
  text-align: right;
}

.drum-row-label.kick-label { color: #ff6040; }
.drum-row-label.snare-label { color: #ffcc40; }
.drum-row-label.clap-label  { color: #cc88ff; }
.drum-row-label.chh-label   { color: #40ffaa; }
.drum-row-label.ohh-label   { color: #40ddff; }

.drum-steps { display:flex; gap:3px; flex:1; }

.drum-step {
  flex:1;
  height: 22px;
  border-radius: 3px;
  background: var(--knob-base);
  border: 1px solid var(--border);
  cursor: pointer;
  transition: background 0.1s, border-color 0.1s, box-shadow 0.1s;
  position: relative;
  min-width: 0;
}

/* Bar grouping: every 4 steps slightly lighter */
.drum-step:nth-child(4n+1) { border-color: rgba(100,200,255,0.2); }

.drum-step.on.kick  { background:#ff4020; border-color:#ff6040; box-shadow:0 0 8px rgba(255,64,32,0.6); }
.drum-step.on.snare { background:#ccaa00; border-color:#ffcc40; box-shadow:0 0 8px rgba(255,200,40,0.5); }
.drum-step.on.clap  { background:#7733cc; border-color:#cc88ff; box-shadow:0 0 8px rgba(200,100,255,0.5); }
.drum-step.on.chh   { background:#008844; border-color:#40ffaa; box-shadow:0 0 8px rgba(64,255,160,0.4); }
.drum-step.on.ohh   { background:#006688; border-color:#40ddff; box-shadow:0 0 8px rgba(64,220,255,0.4); }

/* Playhead highlight */
.drum-step.playing-head {
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.35), 0 0 10px rgba(255,255,255,0.15) !important;
  filter: brightness(1.5);
}

/* Volume knobs per track */
.drum-row-vol {
  width: 28px; height: 28px;
  flex-shrink:0;
}

@media (max-width:600px) {
  .drum-step { height:18px; }
  .drum-row-label { width:32px; font-size:0.32rem; }
  .drum-steps { gap:2px; }
}

/* ── RESPONSIVE ── */
@media (max-width:800px) {
  .synth-panel { grid-template-columns:1fr 1fr; }
  .key.white { width:28px; }
  .key.black { width:18px; margin-left:-9px; margin-right:-9px; }
}

@media (max-width:520px) {
  .synth-panel { grid-template-columns:1fr 1fr; }
  .knob-outer { width:42px; height:42px; }
}
</style>
</head>
<body>
<div class="app">

  <!-- ── HEADER ── -->
  <div class="header">
    <div class="logo">
      <div class="logo-main">HOKUBE GEMINI</div>
      <div class="logo-sub">SOUND LAB · POLYPHONIC SYNTHESIZER</div>
    </div>
    <div class="header-indicators">
      <div class="polyphony-display">VOICES<br><span id="voiceCount">00</span>/08</div>
      <div class="led green"></div>
      <div class="led"></div>
      <div class="led red"></div>
    </div>
  </div>

  <!-- ── DRUM MACHINE ── -->
  <div class="drum-machine">
    <div class="drum-header">
      <div class="drum-title-block">
        <span class="drum-title">TR-808 · Step Sequencer</span>
        <div class="led" style="animation-delay:0.4s"></div>
      </div>
      <div class="drum-controls">
        <!-- BPM -->
        <div class="drum-bpm-wrap">
          <span class="drum-bpm-label">BPM</span>
          <button class="bpm-arrow" onclick="changeBPM(-1)">◀</button>
          <span class="drum-bpm-val" id="drumBPMval">120</span>
          <button class="bpm-arrow" onclick="changeBPM(1)">▶</button>
        </div>
        <!-- TRAP button -->
        <button class="trap-btn" id="trapBtn" onclick="toggleTrap(this)">⚡ TRAP</button>
        <!-- Play/Stop -->
        <button class="drum-play-btn" id="drumPlayBtn" onclick="toggleDrumPlay(this)">▶</button>
      </div>
    </div>

    <div class="drum-grid" id="drumGrid">
      <!-- Rows injected by JS -->
    </div>
  </div>

  <!-- ── SYNTH PANEL ── -->
  <div class="synth-panel">

    <!-- OSC -->
    <div class="section">
      <div class="section-title">Oscillator</div>
      <div class="knobs-row">
        <div class="knob-wrap" data-param="osc1detune" data-min="-50" data-max="50" data-default="0" data-label="DETUNE" data-unit="ct">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">DETUNE</div><div class="knob-value">0ct</div>
        </div>
        <div class="knob-wrap" data-param="osc2pitch" data-min="-12" data-max="12" data-default="0" data-label="PITCH" data-unit="st">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">PITCH</div><div class="knob-value">0st</div>
        </div>
        <div class="knob-wrap" data-param="oscMix" data-min="0" data-max="100" data-default="50" data-label="MIX" data-unit="%">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">MIX</div><div class="knob-value">50%</div>
        </div>
      </div>
      <div class="switch-row">
        <button class="synth-switch on" data-wave="saw" onclick="setWave('saw',this)">SAW</button>
        <button class="synth-switch" data-wave="square" onclick="setWave('square',this)">SQR</button>
        <button class="synth-switch" data-wave="triangle" onclick="setWave('triangle',this)">TRI</button>
        <button class="synth-switch" data-wave="sine" onclick="setWave('sine',this)">SIN</button>
      </div>
    </div>

    <!-- FILTER -->
    <div class="section">
      <div class="section-title">Filter</div>
      <div class="knobs-row">
        <div class="knob-wrap" data-param="filterCutoff" data-min="20" data-max="20000" data-default="4000" data-label="CUTOFF" data-unit="Hz" data-log="1">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">CUTOFF</div><div class="knob-value">4kHz</div>
        </div>
        <div class="knob-wrap" data-param="filterRes" data-min="0.1" data-max="20" data-default="1" data-label="RESO" data-unit="">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">RESO</div><div class="knob-value">1.0</div>
        </div>
        <div class="knob-wrap" data-param="filterEnv" data-min="-100" data-max="100" data-default="30" data-label="ENV" data-unit="%">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">ENV</div><div class="knob-value">30%</div>
        </div>
      </div>
      <div class="switch-row">
        <button class="synth-switch on" onclick="setFilterType('lowpass',this)">LP</button>
        <button class="synth-switch" onclick="setFilterType('highpass',this)">HP</button>
        <button class="synth-switch" onclick="setFilterType('bandpass',this)">BP</button>
      </div>
    </div>

    <!-- ENVELOPE -->
    <div class="section">
      <div class="section-title">Envelope</div>
      <div class="knobs-row">
        <div class="knob-wrap" data-param="envAttack" data-min="0.001" data-max="4" data-default="0.01" data-label="ATK" data-unit="s" data-log="1">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">ATK</div><div class="knob-value">10ms</div>
        </div>
        <div class="knob-wrap" data-param="envDecay" data-min="0.01" data-max="4" data-default="0.3" data-label="DEC" data-unit="s" data-log="1">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">DEC</div><div class="knob-value">300ms</div>
        </div>
        <div class="knob-wrap" data-param="envSustain" data-min="0" data-max="1" data-default="0.6" data-label="SUS" data-unit="">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">SUS</div><div class="knob-value">0.60</div>
        </div>
        <div class="knob-wrap" data-param="envRelease" data-min="0.01" data-max="8" data-default="0.5" data-label="REL" data-unit="s" data-log="1">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">REL</div><div class="knob-value">500ms</div>
        </div>
      </div>
    </div>

    <!-- FX / MOD -->
    <div class="section">
      <div class="section-title">Effects</div>
      <div class="knobs-row">
        <div class="knob-wrap" data-param="chorusRate" data-min="0.1" data-max="8" data-default="0.8" data-label="CHO" data-unit="Hz">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">CHORUS</div><div class="knob-value">0.8Hz</div>
        </div>
        <div class="knob-wrap" data-param="reverbMix" data-min="0" data-max="1" data-default="0.25" data-label="REV" data-unit="">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">REVERB</div><div class="knob-value">0.25</div>
        </div>
        <div class="knob-wrap" data-param="masterVol" data-min="0" data-max="1" data-default="0.7" data-label="VOL" data-unit="">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">VOLUME</div><div class="knob-value">0.70</div>
        </div>
      </div>
      <div class="switch-row">
        <button class="synth-switch on" id="chorusBtn" onclick="toggleChorus(this)">CHORUS</button>
        <button class="synth-switch" id="reverbBtn" onclick="toggleReverb(this)">REVERB</button>
      </div>
    </div>

    <!-- OSCILLOSCOPE — col 3 -->
    <div class="section scope-section">
      <div class="section-title">Oscilloscope</div>
      <div class="scope-wrap">
        <canvas id="oscilloscope"></canvas>
        <div class="scope-labels">
          <span class="scope-label">WAVEFORM</span>
          <span class="scope-label" id="scopeFreq">— Hz</span>
        </div>
      </div>
      <!-- ARP compact -->
      <div class="arp-section">
        <span class="arp-label">ARP</span>
        <div class="arp-steps" id="arpSteps">
          <div class="arp-step"></div><div class="arp-step"></div>
          <div class="arp-step"></div><div class="arp-step"></div>
          <div class="arp-step"></div><div class="arp-step"></div>
          <div class="arp-step"></div><div class="arp-step"></div>
        </div>
        <button class="synth-switch" id="arpBtn" onclick="toggleArp(this)" style="margin-left:auto">OFF</button>
        <div class="knob-wrap" style="flex-direction:row;gap:0.4rem;align-items:center;" data-param="arpBPM" data-min="60" data-max="200" data-default="120" data-label="BPM" data-unit="">
          <div class="knob-outer" style="width:36px;height:36px"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div style="display:flex;flex-direction:column;gap:1px"><div class="knob-label">BPM</div><div class="knob-value" style="font-size:0.5rem">120</div></div>
        </div>
      </div>
    </div>

    <!-- LFO — col 4 -->
    <div class="section">
      <div class="section-title">LFO</div>
      <div class="knobs-row">
        <div class="knob-wrap" data-param="lfoRate" data-min="0.1" data-max="20" data-default="3" data-label="RATE" data-unit="Hz">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">RATE</div><div class="knob-value">3Hz</div>
        </div>
        <div class="knob-wrap" data-param="lfoDepth" data-min="0" data-max="1" data-default="0.3" data-label="DEPTH" data-unit="">
          <div class="knob-outer"><svg class="knob-svg" viewBox="0 0 64 64"><circle class="knob-track" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="150 200" stroke-dashoffset="-25"/><circle class="knob-fill" cx="32" cy="32" r="26" stroke-width="3" stroke-dasharray="0 200" stroke-dashoffset="-25"/></svg><div class="knob-dot"></div></div>
          <div class="knob-label">DEPTH</div><div class="knob-value">0.30</div>
        </div>
      </div>
      <div class="switch-row">
        <button class="synth-switch" onclick="setLfoTarget('pitch',this)">PITCH</button>
        <button class="synth-switch on" onclick="setLfoTarget('filter',this)">FILTER</button>
        <button class="synth-switch" onclick="setLfoTarget('amp',this)">AMP</button>
      </div>
    </div>

  </div><!-- end synth-panel -->

  <!-- ── PRESET BAR ── -->
  <div class="preset-bar">
    <span class="preset-label">PRESETS ·</span>
    <button class="preset-btn selected" onclick="loadPreset('juno',this)">JUNO PAD</button>
    <button class="preset-btn" onclick="loadPreset('lead',this)">ICE LEAD</button>
    <button class="preset-btn" onclick="loadPreset('bass',this)">DEEP BASS</button>
    <button class="preset-btn" onclick="loadPreset('strings',this)">STRINGS</button>
    <button class="preset-btn" onclick="loadPreset('pluck',this)">PLUCK</button>
    <button class="preset-btn" onclick="loadPreset('glass',this)">GLASS</button>
  </div>

  <!-- ── KEYBOARD ── -->
  <div class="keyboard-section">
    <div class="keyboard-header">
      <span class="section-title" style="margin:0">Keyboard · <span style="color:var(--cyan)">2 Octaves</span></span>
      <div style="display:flex;gap:0.5rem;align-items:center;">
        <div class="benders">
          <div class="bender-wrap">
            <div class="bender" id="pitchBend"><div class="bender-fill" id="pbFill" style="height:50%"></div><div class="bender-thumb" id="pbThumb" style="bottom:calc(50% - 5px)"></div></div>
            <div class="bender-label">PB</div>
          </div>
        </div>
        <div style="font-family:var(--font-main);font-size:0.4rem;color:var(--muted);letter-spacing:0.15em;">
          QWERTY<br>MAPPED
        </div>
      </div>
    </div>
    <div class="keyboard-wrap" id="keyboard"></div>
  </div>

</div><!-- end app -->

<script>
// ════════════════════════════════════════════════════════════════════════════
// AUDIO ENGINE
// ════════════════════════════════════════════════════════════════════════════
const AudioContext = window.AudioContext || window.webkitAudioContext;
let actx = null, masterGain, reverbSend, reverbGain, analyser, chorusNodes = null;

const params = {
  waveform: 'sawtooth',
  osc1detune: 0,
  osc2pitch: 0,
  oscMix: 0.5,
  filterCutoff: 4000,
  filterRes: 1,
  filterType: 'lowpass',
  filterEnv: 0.3,
  envAttack: 0.01,
  envDecay: 0.3,
  envSustain: 0.6,
  envRelease: 0.5,
  chorusRate: 0.8,
  reverbMix: 0.25,
  masterVol: 0.7,
  lfoRate: 3,
  lfoDepth: 0.3,
  lfoTarget: 'filter',
  arpBPM: 120,
  chorusOn: true,
  reverbOn: false,
  arpOn: false,
};

const activeVoices = new Map(); // note -> voice obj
const MAX_VOICES = 8;

function initAudio() {
  if (actx) return;
  actx = new AudioContext();

  masterGain = actx.createGain();
  masterGain.gain.value = params.masterVol;

  // Analyser for oscilloscope
  analyser = actx.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0.85;

  // Reverb
  buildReverb();

  masterGain.connect(analyser);
  analyser.connect(actx.destination);

  startOscilloscope();
}

function buildReverb() {
  const len = actx.sampleRate * 2.5;
  const buf = actx.createBuffer(2, len, actx.sampleRate);
  for (let ch = 0; ch < 2; ch++) {
    const d = buf.getChannelData(ch);
    for (let i = 0; i < len; i++) {
      const t = i / actx.sampleRate;
      d[i] = (Math.random()*2-1) * Math.exp(-t*2.8) * (ch===0?1:0.95);
    }
  }
  const conv = actx.createConvolver();
  conv.buffer = buf;
  reverbGain = actx.createGain();
  reverbGain.gain.value = params.reverbOn ? params.reverbMix : 0;
  conv.connect(reverbGain);
  reverbGain.connect(masterGain);
  reverbSend = conv;
}

function noteOn(midiNote) {
  initAudio();
  if (activeVoices.has(midiNote)) return;
  if (activeVoices.size >= MAX_VOICES) {
    const oldest = activeVoices.keys().next().value;
    noteOff(oldest, true);
  }

  const freq = 440 * Math.pow(2, (midiNote - 69) / 12);
  const now = actx.currentTime;

  // OSC 1
  const osc1 = actx.createOscillator();
  osc1.type = params.waveform;
  osc1.frequency.value = freq;
  osc1.detune.value = params.osc1detune;

  // OSC 2
  const osc2 = actx.createOscillator();
  osc2.type = params.waveform;
  osc2.frequency.value = freq * Math.pow(2, params.osc2pitch/12);
  osc2.detune.value = params.osc1detune * -0.7; // counter-detune for width

  // Mix
  const mix1 = actx.createGain(); mix1.gain.value = 1 - params.oscMix * 0.5;
  const mix2 = actx.createGain(); mix2.gain.value = params.oscMix * 0.5 + 0.5;
  osc1.connect(mix1); osc2.connect(mix2);

  // Filter
  const filter = actx.createBiquadFilter();
  filter.type = params.filterType;
  filter.frequency.value = params.filterCutoff * 0.3;
  filter.Q.value = params.filterRes;

  // Filter envelope
  const fEnvAmt = params.filterCutoff * params.filterEnv;
  filter.frequency.setValueAtTime(params.filterCutoff * 0.3, now);
  filter.frequency.linearRampToValueAtTime(params.filterCutoff * 0.3 + fEnvAmt, now + params.envAttack);
  filter.frequency.exponentialRampToValueAtTime(Math.max(20, params.filterCutoff * 0.3 + fEnvAmt * 0.3), now + params.envAttack + params.envDecay);

  // Amp envelope
  const ampEnv = actx.createGain();
  ampEnv.gain.setValueAtTime(0, now);
  ampEnv.gain.linearRampToValueAtTime(0.28, now + params.envAttack);
  ampEnv.gain.exponentialRampToValueAtTime(Math.max(0.001, 0.28 * params.envSustain), now + params.envAttack + params.envDecay);

  // LFO
  const lfo = actx.createOscillator();
  lfo.frequency.value = params.lfoRate;
  const lfoGain = actx.createGain();
  lfoGain.gain.value = 0;

  if (params.lfoTarget === 'pitch') {
    lfoGain.gain.value = params.lfoDepth * 50;
    lfo.connect(lfoGain); lfoGain.connect(osc1.detune); lfoGain.connect(osc2.detune);
  } else if (params.lfoTarget === 'filter') {
    lfoGain.gain.value = params.lfoDepth * params.filterCutoff * 0.4;
    lfo.connect(lfoGain); lfoGain.connect(filter.frequency);
  } else {
    lfoGain.gain.value = params.lfoDepth * 0.15;
    lfo.connect(lfoGain); lfoGain.connect(ampEnv.gain);
  }

  // Chain
  mix1.connect(filter); mix2.connect(filter);
  filter.connect(ampEnv);
  ampEnv.connect(masterGain);
  if (params.reverbOn) ampEnv.connect(reverbSend);

  // Chorus
  if (params.chorusOn) {
    const delay = actx.createDelay(0.05);
    delay.delayTime.value = 0.02;
    const choLFO = actx.createOscillator();
    choLFO.frequency.value = params.chorusRate;
    const choGain = actx.createGain(); choGain.gain.value = 0.008;
    choLFO.connect(choGain); choGain.connect(delay.delayTime);
    const choMix = actx.createGain(); choMix.gain.value = 0.5;
    ampEnv.connect(delay); delay.connect(choMix); choMix.connect(masterGain);
    choLFO.start(now);
    osc1.start(now); osc2.start(now); lfo.start(now);
    activeVoices.set(midiNote, {osc1,osc2,filter,ampEnv,lfo,choLFO,delay,freq,now});
    updateVoiceCount();
    return;
  }

  osc1.start(now); osc2.start(now); lfo.start(now);
  activeVoices.set(midiNote, {osc1,osc2,filter,ampEnv,lfo,freq,now});
  updateVoiceCount();
}

function noteOff(midiNote, immediate=false) {
  const v = activeVoices.get(midiNote);
  if (!v) return;
  const now = actx.currentTime;
  const rel = immediate ? 0.05 : params.envRelease;
  v.ampEnv.gain.cancelScheduledValues(now);
  v.ampEnv.gain.setValueAtTime(v.ampEnv.gain.value, now);
  v.ampEnv.gain.exponentialRampToValueAtTime(0.0001, now + rel);
  [v.osc1,v.osc2,v.lfo].forEach(n => { try { n.stop(now + rel + 0.05); } catch(e){} });
  if (v.choLFO) try { v.choLFO.stop(now + rel + 0.05); } catch(e){}
  activeVoices.delete(midiNote);
  updateVoiceCount();
}

function updateVoiceCount() {
  document.getElementById('voiceCount').textContent =
    String(activeVoices.size).padStart(2,'0');
}

// ════════════════════════════════════════════════════════════════════════════
// OSCILLOSCOPE
// ════════════════════════════════════════════════════════════════════════════
function startOscilloscope() {
  const canvas = document.getElementById('oscilloscope');
  const ctx = canvas.getContext('2d');
  const buf = new Float32Array(analyser.fftSize);

  function resize() {
    canvas.width = canvas.offsetWidth * devicePixelRatio;
    canvas.height = canvas.offsetHeight * devicePixelRatio;
  }
  resize();
  new ResizeObserver(resize).observe(canvas);

  let phase = 0;

  function draw() {
    requestAnimationFrame(draw);
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    // Background
    ctx.fillStyle = '#010a0f';
    ctx.fillRect(0,0,W,H);

    analyser.getFloatTimeDomainData(buf);

    const hasSignal = activeVoices.size > 0;

    if (!hasSignal) {
      // Flat idle line with subtle noise
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(0,212,255,0.25)';
      ctx.lineWidth = 1.5 * devicePixelRatio;
      ctx.shadowColor = 'rgba(0,212,255,0.3)';
      ctx.shadowBlur = 4;
      for (let x = 0; x < W; x++) {
        const noise = (Math.random()-0.5)*0.008*H;
        const y = H/2 + noise;
        x===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
      }
      ctx.stroke();
      return;
    }

    // Find zero crossing for stable display
    let start = 0;
    for (let i = 1; i < buf.length-1; i++) {
      if (buf[i-1] < 0 && buf[i] >= 0) { start = i; break; }
    }

    const sliceW = W / (buf.length * 0.25);

    // Glow layer
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(0,212,255,0.15)';
    ctx.lineWidth = 6 * devicePixelRatio;
    ctx.shadowColor = 'rgba(0,212,255,0.8)';
    ctx.shadowBlur = 18;
    for (let i = 0; i < W/sliceW; i++) {
      const idx = start + i;
      if (idx >= buf.length) break;
      const x = i * sliceW;
      const y = (1 - (buf[idx]+1)/2) * H;
      i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Sharp line
    ctx.beginPath();
    ctx.strokeStyle = '#00d4ff';
    ctx.lineWidth = 1.8 * devicePixelRatio;
    ctx.shadowColor = 'rgba(0,212,255,0.9)';
    ctx.shadowBlur = 8;
    for (let i = 0; i < W/sliceW; i++) {
      const idx = start + i;
      if (idx >= buf.length) break;
      const x = i * sliceW;
      const y = (1 - (buf[idx]+1)/2) * H;
      i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Freq display
    if (activeVoices.size > 0) {
      const f = [...activeVoices.values()][0].freq;
      document.getElementById('scopeFreq').textContent =
        f < 1000 ? f.toFixed(1)+' Hz' : (f/1000).toFixed(2)+' kHz';
    } else {
      document.getElementById('scopeFreq').textContent = '— Hz';
    }
  }
  draw();
}

// ════════════════════════════════════════════════════════════════════════════
// KNOBS
// ════════════════════════════════════════════════════════════════════════════
const KNOB_ARC = 150; // degrees of travel
const KNOB_START = 135; // starting angle in degrees

document.querySelectorAll('.knob-wrap').forEach(wrap => {
  const param = wrap.dataset.param;
  const min = parseFloat(wrap.dataset.min);
  const max = parseFloat(wrap.dataset.max);
  const isLog = !!wrap.dataset.log;
  const unit = wrap.dataset.unit || '';
  let norm = getNorm(param, min, max, isLog);

  const outer = wrap.querySelector('.knob-outer');
  const dot = wrap.querySelector('.knob-dot');
  const fill = wrap.querySelector('.knob-fill');
  const valEl = wrap.querySelector('.knob-value');

  function render(n) {
    const deg = KNOB_START + n * KNOB_ARC; // 135..285
    dot.style.transform = `rotate(${deg}deg)`;
    // Arc: circumference = 2*PI*26 ≈ 163.4, we use dasharray 150 total
    const arcLen = n * KNOB_ARC / 300 * 150; // scaled
    const offset = -25 - (n * KNOB_ARC / 300 * 150);
    fill.style.strokeDasharray = `${n * 150} 200`;
  }

  function updateValue(n) {
    norm = Math.max(0, Math.min(1, n));
    const val = isLog
      ? Math.exp(Math.log(min) + norm * (Math.log(max) - Math.log(min)))
      : min + norm * (max - min);
    params[param] = val;
    render(norm);
    valEl.textContent = formatVal(val, unit, param);
    applyParam(param, val);
  }

  render(norm);
  updateValue(norm);

  // Mouse drag
  let dragging = false, startY = 0, startNorm = 0;

  outer.addEventListener('mousedown', e => {
    dragging = true; startY = e.clientY; startNorm = norm;
    outer.classList.add('active');
    document.body.style.cursor = 'ns-resize';
    e.preventDefault();
  });
  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const delta = (startY - e.clientY) / 200;
    updateValue(startNorm + delta);
  });
  document.addEventListener('mouseup', () => {
    if (dragging) { dragging = false; outer.classList.remove('active'); document.body.style.cursor=''; }
  });

  // Touch
  outer.addEventListener('touchstart', e => {
    startY = e.touches[0].clientY; startNorm = norm;
    outer.classList.add('active');
    e.preventDefault();
  }, {passive:false});
  outer.addEventListener('touchmove', e => {
    const delta = (startY - e.touches[0].clientY) / 180;
    updateValue(startNorm + delta);
    e.preventDefault();
  }, {passive:false});
  outer.addEventListener('touchend', () => outer.classList.remove('active'));

  // Scroll wheel
  outer.addEventListener('wheel', e => {
    updateValue(norm - e.deltaY * 0.002);
    e.preventDefault();
  }, {passive:false});

  // Double click reset
  outer.addEventListener('dblclick', () => {
    norm = getNorm(param, min, max, isLog);
    updateValue(norm);
  });

  wrap._updateValue = updateValue;
  wrap._norm = () => norm;
});

function getNorm(param, min, max, isLog) {
  const val = params[param];
  if (isLog) return (Math.log(val) - Math.log(min)) / (Math.log(max) - Math.log(min));
  return (val - min) / (max - min);
}

function formatVal(v, unit, param) {
  if (unit === 'Hz') {
    if (param === 'filterCutoff') return v >= 1000 ? (v/1000).toFixed(1)+'kHz' : Math.round(v)+'Hz';
    return v.toFixed(1)+'Hz';
  }
  if (unit === 's') return v >= 1 ? v.toFixed(2)+'s' : Math.round(v*1000)+'ms';
  if (unit === 'ct') return Math.round(v)+'ct';
  if (unit === 'st') return (v>=0?'+':'')+Math.round(v)+'st';
  if (unit === '%') return Math.round(v)+'%';
  return v.toFixed(2);
}

function applyParam(param, val) {
  if (param === 'masterVol') masterGain && (masterGain.gain.value = val);
  if (param === 'reverbMix' && reverbGain) reverbGain.gain.value = params.reverbOn ? val : 0;
}

// ════════════════════════════════════════════════════════════════════════════
// TOGGLE / SWITCHES
// ════════════════════════════════════════════════════════════════════════════
function setWave(w, btn) {
  params.waveform = w === 'saw' ? 'sawtooth' : w === 'square' ? 'square' : w;
  document.querySelectorAll('[data-wave]').forEach(b => b.classList.remove('on'));
  btn.classList.add('on');
}

function setFilterType(t, btn) {
  params.filterType = t;
  btn.closest('.section').querySelectorAll('.synth-switch').forEach(b => b.classList.remove('on'));
  btn.classList.add('on');
}

function setLfoTarget(t, btn) {
  params.lfoTarget = t;
  btn.closest('.section').querySelectorAll('.synth-switch').forEach(b => b.classList.remove('on'));
  btn.classList.add('on');
}

function toggleChorus(btn) {
  params.chorusOn = !params.chorusOn;
  btn.classList.toggle('on', params.chorusOn);
}

function toggleReverb(btn) {
  params.reverbOn = !params.reverbOn;
  btn.classList.toggle('on', params.reverbOn);
  if (reverbGain) reverbGain.gain.value = params.reverbOn ? params.reverbMix : 0;
}

// ════════════════════════════════════════════════════════════════════════════
// PRESETS
// ════════════════════════════════════════════════════════════════════════════
const PRESETS = {
  juno:    { waveform:'sawtooth', osc1detune:8, osc2pitch:0, oscMix:0.5, filterCutoff:2800, filterRes:2, filterEnv:0.4, envAttack:0.05, envDecay:0.5, envSustain:0.7, envRelease:0.8, lfoRate:0.5, lfoDepth:0.2, lfoTarget:'filter', chorusOn:true, reverbOn:true, reverbMix:0.3 },
  lead:    { waveform:'sawtooth', osc1detune:2, osc2pitch:7, oscMix:0.6, filterCutoff:6000, filterRes:8, filterEnv:0.6, envAttack:0.005, envDecay:0.2, envSustain:0.5, envRelease:0.3, lfoRate:5, lfoDepth:0.4, lfoTarget:'pitch', chorusOn:false, reverbOn:false },
  bass:    { waveform:'square', osc1detune:0, osc2pitch:-12, oscMix:0.7, filterCutoff:600, filterRes:4, filterEnv:0.7, envAttack:0.005, envDecay:0.15, envSustain:0.3, envRelease:0.15, lfoRate:0.3, lfoDepth:0.1, lfoTarget:'filter', chorusOn:false, reverbOn:false },
  strings: { waveform:'sawtooth', osc1detune:14, osc2pitch:0, oscMix:0.5, filterCutoff:3500, filterRes:1.5, filterEnv:0.2, envAttack:0.4, envDecay:0.8, envSustain:0.8, envRelease:1.5, lfoRate:4, lfoDepth:0.15, lfoTarget:'pitch', chorusOn:true, reverbOn:true, reverbMix:0.45 },
  pluck:   { waveform:'triangle', osc1detune:3, osc2pitch:0, oscMix:0.5, filterCutoff:5000, filterRes:3, filterEnv:0.8, envAttack:0.002, envDecay:0.25, envSustain:0.05, envRelease:0.4, lfoRate:2, lfoDepth:0.1, lfoTarget:'filter', chorusOn:true, reverbOn:true, reverbMix:0.25 },
  glass:   { waveform:'sine', osc1detune:0, osc2pitch:12, oscMix:0.4, filterCutoff:8000, filterRes:6, filterEnv:0.3, envAttack:0.1, envDecay:0.6, envSustain:0.4, envRelease:2.0, lfoRate:1.5, lfoDepth:0.25, lfoTarget:'amp', chorusOn:false, reverbOn:true, reverbMix:0.6 },
};

function loadPreset(name, btn) {
  const p = PRESETS[name]; if (!p) return;
  Object.assign(params, p);
  document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
  // Update all knobs
  document.querySelectorAll('.knob-wrap').forEach(wrap => {
    if (wrap._updateValue) {
      const param = wrap.dataset.param;
      const min = parseFloat(wrap.dataset.min);
      const max = parseFloat(wrap.dataset.max);
      const isLog = !!wrap.dataset.log;
      const n = getNorm(param, min, max, isLog);
      wrap._updateValue(n);
    }
  });
  // Update switches
  document.querySelectorAll('[data-wave]').forEach(b => b.classList.toggle('on', b.dataset.wave === (p.waveform==='sawtooth'?'saw':p.waveform)));
  document.getElementById('chorusBtn').classList.toggle('on', !!p.chorusOn);
  document.getElementById('reverbBtn').classList.toggle('on', !!p.reverbOn);
  if (reverbGain) reverbGain.gain.value = p.reverbOn ? p.reverbMix : 0;
}

// ════════════════════════════════════════════════════════════════════════════
// KEYBOARD
// ════════════════════════════════════════════════════════════════════════════
const NOTES_2OCT = [
  {note:60,type:'white',label:'A'},{note:61,type:'black',label:'W'},
  {note:62,type:'white',label:'S'},{note:63,type:'black',label:'E'},
  {note:64,type:'white',label:'D'},{note:65,type:'white',label:'F'},
  {note:66,type:'black',label:'T'},{note:67,type:'white',label:'G'},
  {note:68,type:'black',label:'Y'},{note:69,type:'white',label:'H'},
  {note:70,type:'black',label:'U'},{note:71,type:'white',label:'J'},
  {note:72,type:'white',label:'K'},{note:73,type:'black',label:'O'},
  {note:74,type:'white',label:'L'},{note:75,type:'black',label:'P'},
  {note:76,type:'white',label:';'},{note:77,type:'white',label:"'"},{note:78,type:'black',label:']'},
  {note:79,type:'white',label:'Z'},{note:80,type:'black',label:'X'},
  {note:81,type:'white',label:'C'},
];

const keyEl = document.getElementById('keyboard');
const noteToKey = new Map();

NOTES_2OCT.forEach(({note,type,label}) => {
  const k = document.createElement('div');
  k.className = `key ${type}`;
  k.dataset.note = note;
  const hint = document.createElement('span');
  hint.className = 'key-hint';
  hint.textContent = label;
  k.appendChild(hint);
  keyEl.appendChild(k);
  noteToKey.set(note, k);

  k.addEventListener('pointerdown', e => { e.preventDefault(); noteOn(note); k.setPointerCapture(e.pointerId); k.classList.add('active'); });
  k.addEventListener('pointerup', () => { noteOff(note); k.classList.remove('active'); });
  k.addEventListener('pointerleave', () => { noteOff(note); k.classList.remove('active'); });
});

// Keyboard map
const keyMap = {
  'KeyA':60,'KeyW':61,'KeyS':62,'KeyE':63,'KeyD':64,'KeyF':65,'KeyT':66,
  'KeyG':67,'KeyY':68,'KeyH':69,'KeyU':70,'KeyJ':71,'KeyK':72,'KeyO':73,
  'KeyL':74,'KeyP':75,'Semicolon':76,'Quote':77,'BracketRight':78,
  'KeyZ':79,'KeyX':80,'KeyC':81
};

document.addEventListener('keydown', e => {
  if (e.repeat || e.target.tagName==='INPUT') return;
  const note = keyMap[e.code];
  if (note !== undefined) {
    noteOn(note);
    noteToKey.get(note)?.classList.add('active');
  }
});
document.addEventListener('keyup', e => {
  const note = keyMap[e.code];
  if (note !== undefined) {
    noteOff(note);
    noteToKey.get(note)?.classList.remove('active');
  }
});

// ════════════════════════════════════════════════════════════════════════════
// ARPEGGIATOR
// ════════════════════════════════════════════════════════════════════════════
let arpInterval = null;
let arpStep = 0;
const arpStepEls = document.querySelectorAll('.arp-step');

function toggleArp(btn) {
  params.arpOn = !params.arpOn;
  btn.textContent = params.arpOn ? 'ON' : 'OFF';
  btn.classList.toggle('on', params.arpOn);
  if (params.arpOn) startArp(); else stopArp();
}

function startArp() {
  stopArp();
  const interval = 60000 / params.arpBPM / 2;
  const heldNotes = [...activeVoices.keys()];
  if (heldNotes.length === 0) return;
  arpInterval = setInterval(() => {
    arpStepEls.forEach(s => s.classList.remove('active'));
    arpStepEls[arpStep % 8].classList.add('active');
    arpStep++;
  }, interval);
}

function stopArp() {
  if (arpInterval) { clearInterval(arpInterval); arpInterval = null; }
  arpStepEls.forEach(s => s.classList.remove('active'));
}


// ════════════════════════════════════════════════════════════════════════════
// TR-808 DRUM MACHINE
// ════════════════════════════════════════════════════════════════════════════

const DRUM_TRACKS = [
  { id:'kick',  label:'KICK',  cls:'kick-label'  },
  { id:'snare', label:'SNARE', cls:'snare-label'  },
  { id:'clap',  label:'CLAP',  cls:'clap-label'   },
  { id:'chh',   label:'C.HAT', cls:'chh-label'    },
  { id:'ohh',   label:'O.HAT', cls:'ohh-label'    },
];

// Default patterns (16 steps each)
const drumPatterns = {
  kick:  [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
  snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
  clap:  [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,1,0],
  chh:   [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],
  ohh:   [0,0,0,1, 0,0,0,0, 0,0,0,1, 0,0,0,0],
};

const drumVols = { kick:0.9, snare:0.7, clap:0.65, chh:0.5, ohh:0.55 };

let drumBPM = 120;
let drumPlaying = false;
let drumStep = 0;
let drumScheduler = null;
let drumNextTime = 0;
let trapOn = false;

// ── Build Grid UI ────────────────────────────────────────────────────────
const drumGrid = document.getElementById('drumGrid');

DRUM_TRACKS.forEach(track => {
  const row = document.createElement('div');
  row.className = 'drum-row';
  row.innerHTML = `<div class="drum-row-label ${track.cls}">${track.label}</div>
    <div class="drum-steps" id="steps-${track.id}"></div>`;

  const stepsEl = row.querySelector(`#steps-${track.id}`);
  for (let i = 0; i < 16; i++) {
    const btn = document.createElement('div');
    btn.className = `drum-step ${track.id}`;
    btn.dataset.step = i;
    btn.dataset.track = track.id;
    if (drumPatterns[track.id][i]) btn.classList.add('on');
    btn.addEventListener('click', () => {
      drumPatterns[track.id][i] ^= 1;
      btn.classList.toggle('on', !!drumPatterns[track.id][i]);
    });
    stepsEl.appendChild(btn);
  }
  drumGrid.appendChild(row);
});

// ── TR-808 Sound Synthesis ────────────────────────────────────────────────

function triggerDrum(type, time) {
  initAudio();
  const ctx = actx;
  const vol = drumVols[type] || 0.7;

  switch(type) {
    case 'kick':  synth808Kick(ctx, time, vol); break;
    case 'snare': synth808Snare(ctx, time, vol); break;
    case 'clap':  synth808Clap(ctx, time, vol); break;
    case 'chh':   synth808CHH(ctx, time, vol); break;
    case 'ohh':   synth808OHH(ctx, time, vol); break;
  }
}

// ── KICK 808 ─────────────────────────────────────────────────────────────
// Classic pitch-dropping sine + sub thump. TRAP mode adds heavy distortion.
function synth808Kick(ctx, time, vol) {
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(160, time);
  osc.frequency.exponentialRampToValueAtTime(trapOn ? 28 : 42, time + (trapOn ? 0.9 : 0.55));

  // Sub oscillator for extra weight
  const sub = ctx.createOscillator();
  sub.type = 'sine';
  sub.frequency.setValueAtTime(80, time);
  sub.frequency.exponentialRampToValueAtTime(trapOn ? 22 : 35, time + (trapOn ? 1.0 : 0.55));

  // Click transient
  const clickOsc = ctx.createOscillator();
  clickOsc.type = 'triangle';
  clickOsc.frequency.setValueAtTime(900, time);
  clickOsc.frequency.exponentialRampToValueAtTime(60, time + 0.025);
  const clickGain = ctx.createGain();
  clickGain.gain.setValueAtTime(0.6, time);
  clickGain.gain.exponentialRampToValueAtTime(0.001, time + 0.04);

  const env = ctx.createGain();
  env.gain.setValueAtTime(vol * (trapOn ? 1.4 : 1.0), time);
  env.gain.exponentialRampToValueAtTime(0.001, time + (trapOn ? 1.1 : 0.65));

  const subGain = ctx.createGain();
  subGain.gain.value = 0.55;

  if (trapOn) {
    // Heavy waveshaper distortion — 808 trap saturation
    const ws = ctx.createWaveShaper();
    ws.curve = makeTrapDistCurve(380);
    ws.oversample = '4x';

    // Low-pass to keep it bassy after distortion
    const lp = ctx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = 180;
    lp.Q.value = 2.5;

    // Extra gain stage before distortion (like running into a saturated channel)
    const preGain = ctx.createGain();
    preGain.gain.value = 3.5;

    osc.connect(preGain); sub.connect(subGain); subGain.connect(preGain);
    preGain.connect(ws);
    ws.connect(lp);
    clickOsc.connect(clickGain);
    clickGain.connect(env);
    lp.connect(env);
    env.connect(masterGain);

    // Second layer: raw sub bypass (keeps the low-end tight)
    const bypass = ctx.createGain();
    bypass.gain.value = 0.4;
    sub.connect(bypass);
    bypass.connect(masterGain);
  } else {
    osc.connect(env);
    sub.connect(subGain); subGain.connect(env);
    clickOsc.connect(clickGain); clickGain.connect(env);
    env.connect(masterGain);
  }

  osc.start(time); osc.stop(time + 1.2);
  sub.start(time); sub.stop(time + 1.2);
  clickOsc.start(time); clickOsc.stop(time + 0.05);
}

// TRAP distortion curve — asymmetric hard clip with warmth
function makeTrapDistCurve(amount) {
  const n = 512;
  const curve = new Float32Array(n);
  for (let i = 0; i < n; i++) {
    const x = (i * 2) / n - 1;
    // Asymmetric: harder on positive (punch), softer on negative (warmth)
    if (x >= 0) curve[i] = 1 - Math.exp(-amount * x);
    else curve[i] = -1 + Math.exp(amount * 0.6 * x);
  }
  return curve;
}

// ── SNARE 808 ─────────────────────────────────────────────────────────────
function synth808Snare(ctx, time, vol) {
  // Tone component
  const osc = ctx.createOscillator();
  osc.type = 'triangle';
  osc.frequency.setValueAtTime(200, time);
  osc.frequency.exponentialRampToValueAtTime(80, time + 0.15);

  const toneEnv = ctx.createGain();
  toneEnv.gain.setValueAtTime(vol * 0.7, time);
  toneEnv.gain.exponentialRampToValueAtTime(0.001, time + 0.18);

  // Noise component (the snappy body)
  const bufLen = ctx.sampleRate * 0.22;
  const noiseBuf = ctx.createBuffer(1, bufLen, ctx.sampleRate);
  const nd = noiseBuf.getChannelData(0);
  for (let i = 0; i < bufLen; i++) nd[i] = Math.random() * 2 - 1;

  const noiseSrc = ctx.createBufferSource();
  noiseSrc.buffer = noiseBuf;

  const noiseHP = ctx.createBiquadFilter();
  noiseHP.type = 'highpass';
  noiseHP.frequency.value = 1200;

  const noiseEnv = ctx.createGain();
  noiseEnv.gain.setValueAtTime(vol * 0.9, time);
  noiseEnv.gain.exponentialRampToValueAtTime(0.001, time + 0.2);

  osc.connect(toneEnv); toneEnv.connect(masterGain);
  noiseSrc.connect(noiseHP); noiseHP.connect(noiseEnv); noiseEnv.connect(masterGain);

  osc.start(time); osc.stop(time + 0.2);
  noiseSrc.start(time); noiseSrc.stop(time + 0.25);
}

// ── CLAP 808 ──────────────────────────────────────────────────────────────
function synth808Clap(ctx, time, vol) {
  // 3 layered noise bursts slightly offset (the clap transient smear)
  const delays = [0, 0.01, 0.022, 0.035];
  delays.forEach((d, i) => {
    const len = ctx.sampleRate * (i === delays.length-1 ? 0.15 : 0.025);
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let j = 0; j < len; j++) data[j] = Math.random() * 2 - 1;

    const src = ctx.createBufferSource(); src.buffer = buf;

    const bp = ctx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 1800 + i * 200;
    bp.Q.value = 0.8;

    const g = ctx.createGain();
    const isLast = i === delays.length - 1;
    g.gain.setValueAtTime(vol * (isLast ? 0.7 : 1.0), time + d);
    g.gain.exponentialRampToValueAtTime(0.001, time + d + (isLast ? 0.14 : 0.03));

    src.connect(bp); bp.connect(g); g.connect(masterGain);
    src.start(time + d); src.stop(time + d + 0.2);
  });
}

// ── CLOSED HI-HAT 808 ─────────────────────────────────────────────────────
function synth808CHH(ctx, time, vol) {
  // 6 detuned square oscillators (metallic character of a real hi-hat)
  const freqs = [205.3, 310.7, 418.2, 513.9, 627.4, 834.6];
  const merger = ctx.createGain(); merger.gain.value = vol * 0.25;

  freqs.forEach(f => {
    const o = ctx.createOscillator();
    o.type = 'square';
    o.frequency.value = f;
    o.connect(merger);
    o.start(time); o.stop(time + 0.07);
  });

  const hp = ctx.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 7000;

  const env = ctx.createGain();
  env.gain.setValueAtTime(1, time);
  env.gain.exponentialRampToValueAtTime(0.001, time + 0.065);

  merger.connect(hp); hp.connect(env); env.connect(masterGain);
}

// ── OPEN HI-HAT 808 ───────────────────────────────────────────────────────
function synth808OHH(ctx, time, vol) {
  const freqs = [205.3, 310.7, 418.2, 513.9, 627.4, 834.6];
  const merger = ctx.createGain(); merger.gain.value = vol * 0.22;

  freqs.forEach(f => {
    const o = ctx.createOscillator();
    o.type = 'square';
    o.frequency.value = f;
    o.connect(merger);
    o.start(time); o.stop(time + 0.5);
  });

  const hp = ctx.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 6000;

  const env = ctx.createGain();
  env.gain.setValueAtTime(1, time);
  env.gain.exponentialRampToValueAtTime(0.001, time + 0.45);

  merger.connect(hp); hp.connect(env); env.connect(masterGain);
}

// ── Step Sequencer Scheduler ──────────────────────────────────────────────
const SCHEDULE_AHEAD = 0.1; // seconds
const SCHEDULER_INTERVAL = 25; // ms

function drumSchedulerLoop() {
  initAudio();
  while (drumNextTime < actx.currentTime + SCHEDULE_AHEAD) {
    scheduleDrumStep(drumStep, drumNextTime);
    advanceDrumStep();
  }
}

function scheduleDrumStep(step, time) {
  DRUM_TRACKS.forEach(track => {
    if (drumPatterns[track.id][step]) {
      triggerDrum(track.id, time);
    }
  });
  // Visual playhead — deferred to requestAnimationFrame
  scheduleVisualStep(step, time);
}

// Visual queue for playhead highlighting
const visualQueue = [];
function scheduleVisualStep(step, time) {
  visualQueue.push({ step, time });
}

let lastVisualStep = -1;
function updatePlayhead() {
  if (drumPlaying) requestAnimationFrame(updatePlayhead);
  if (!actx) return;
  const now = actx.currentTime;
  while (visualQueue.length && visualQueue[0].time <= now) {
    const { step } = visualQueue.shift();
    if (step !== lastVisualStep) {
      // Clear previous
      document.querySelectorAll('.drum-step.playing-head').forEach(el => el.classList.remove('playing-head'));
      // Highlight current column
      DRUM_TRACKS.forEach(track => {
        const el = document.querySelector(`#steps-${track.id} [data-step="${step}"]`);
        if (el) el.classList.add('playing-head');
      });
      lastVisualStep = step;
    }
  }
}

function advanceDrumStep() {
  const secPerBeat = 60.0 / drumBPM;
  const secPerStep = secPerBeat / 4; // 16th note
  drumNextTime += secPerStep;
  drumStep = (drumStep + 1) % 16;
}

function toggleDrumPlay(btn) {
  initAudio();
  drumPlaying = !drumPlaying;
  btn.textContent = drumPlaying ? '■' : '▶';
  btn.classList.toggle('playing', drumPlaying);

  if (drumPlaying) {
    drumStep = 0;
    drumNextTime = actx.currentTime + 0.05;
    drumScheduler = setInterval(drumSchedulerLoop, SCHEDULER_INTERVAL);
    requestAnimationFrame(updatePlayhead);
  } else {
    clearInterval(drumScheduler);
    drumScheduler = null;
    document.querySelectorAll('.drum-step.playing-head').forEach(el => el.classList.remove('playing-head'));
    visualQueue.length = 0;
  }
}

function changeBPM(delta) {
  drumBPM = Math.max(60, Math.min(200, drumBPM + delta));
  document.getElementById('drumBPMval').textContent = drumBPM;
}

// Mouse wheel on BPM val
document.getElementById('drumBPMval').addEventListener('wheel', e => {
  changeBPM(e.deltaY < 0 ? 1 : -1);
  e.preventDefault();
}, {passive:false});

function toggleTrap(btn) {
  trapOn = !trapOn;
  btn.classList.toggle('on', trapOn);
  // Visual: pulsing red glow on kick row when trap active
  document.querySelector('.kick-label').style.textShadow = trapOn
    ? '0 0 12px rgba(255,80,20,0.9)' : '';
  document.querySelectorAll('.drum-step.kick.on').forEach(el => {
    el.style.boxShadow = trapOn ? '0 0 16px rgba(255,60,10,0.9)' : '';
  });
}

window.addEventListener('load', () => {
  // Lazy init: start oscilloscope draw loop without audio
  const canvas = document.getElementById('oscilloscope');
  const ctx2 = canvas.getContext('2d');
  function idleDraw() {
    if (actx) return; // audio engine will take over
    requestAnimationFrame(idleDraw);
    canvas.width = canvas.offsetWidth * devicePixelRatio;
    canvas.height = canvas.offsetHeight * devicePixelRatio;
    const W = canvas.width, H = canvas.height;
    ctx2.fillStyle = '#010a0f';
    ctx2.fillRect(0,0,W,H);
    ctx2.beginPath();
    ctx2.strokeStyle = 'rgba(0,212,255,0.2)';
    ctx2.lineWidth = 1.5 * devicePixelRatio;
    for (let x=0; x<W; x++) {
      const y = H/2 + (Math.random()-0.5)*3;
      x===0 ? ctx2.moveTo(x,y) : ctx2.lineTo(x,y);
    }
    ctx2.stroke();
  }
  idleDraw();
});
</script>
</body>
</html>
