<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>HOKUBE GEMINI LAB (WebAudio)</title>
<style>
  :root{
    --bg:#070A12;
    --panel:#0B1020;
    --stroke:#23346f;
    --text:#EAF0FF;
    --muted:#9AA6D6;
    --accent:#7AA2FF;
    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --glow: 0 0 0 1px rgba(122,162,255,.22), 0 0 22px rgba(122,162,255,.14);
  }
  *{box-sizing:border-box;}
  body{
    margin:0;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    color:var(--text);
    background:
      radial-gradient(900px 500px at 20% 0%, rgba(122,162,255,.12), transparent 60%),
      radial-gradient(900px 500px at 80% 10%, rgba(122,162,255,.10), transparent 55%),
      var(--bg);
  }

  .wrap{ max-width: 760px; margin: 0 auto; padding: 10px 10px calc(12px + env(safe-area-inset-bottom)); }
  .top{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding: 8px 10px; margin-bottom: 8px;
    border:1px solid var(--stroke); border-radius:16px;
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
    box-shadow: var(--shadow);
  }
  .title{ font-size:13px; letter-spacing:.6px; text-transform:uppercase; margin:0; }
  .status{ font-size:11px; color:var(--muted); margin-top:4px; }
  .btns{ display:flex; gap:8px; align-items:center; flex:0 0 auto; }
  button{
    border:1px solid var(--stroke);
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    color:var(--text);
    padding:9px 10px;
    border-radius:12px;
    box-shadow: var(--glow);
    letter-spacing:.2px;
    cursor:pointer;
    -webkit-tap-highlight-color: transparent;
  }
  button.on{ border-color: var(--accent); box-shadow: 0 0 0 1px rgba(122,162,255,.35), 0 0 28px rgba(122,162,255,.18); }
  button:active{ transform: translateY(1px); }

  /* Compact grid */
  .panel{
    border:1px solid var(--stroke);
    border-radius:18px;
    padding:10px;
    background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    box-shadow: var(--shadow);
  }
  .row{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:10px;
  }
  @media (max-width: 700px){
    .row{ grid-template-columns: 1fr; }
  }

  .block{
    border:1px solid var(--stroke);
    border-radius:14px;
    padding:10px;
    background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
  }
  .block h3{
    margin:0 0 8px;
    font-size:12px;
    color:var(--text);
    opacity:.92;
    letter-spacing:.6px;
    text-transform:uppercase;
  }

  /* JUNO-style slider strip */
  .strip{
    display:flex;
    gap:10px;
    align-items:flex-end;
    justify-content:space-between;
    flex-wrap:wrap;
  }
  .sliderCol{
    width: 60px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
    padding:6px 4px;
    border:1px solid rgba(255,255,255,.05);
    border-radius:12px;
    background: rgba(0,0,0,.14);
  }
  .lab{
    font-size:10px;
    color:var(--muted);
    text-align:center;
    line-height:1.1;
    min-height: 24px;
  }
  .val{
    font-size:10px;
    color:var(--text);
    opacity:.9;
    font-variant-numeric: tabular-nums;
  }

  /* Vertical range */
  input[type="range"].v{
    -webkit-appearance: none;
    appearance:none;
    width: 120px;
    height: 28px;
    transform: rotate(-90deg);
    transform-origin: 50% 50%;
    touch-action: none;
    background: transparent;
  }
  input[type="range"].v::-webkit-slider-runnable-track{
    height: 6px;
    border-radius: 999px;
    background: rgba(255,255,255,.10);
    border:1px solid rgba(122,162,255,.18);
  }
  input[type="range"].v::-webkit-slider-thumb{
    -webkit-appearance:none;
    width: 18px; height: 18px;
    border-radius: 6px;
    background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.06));
    border:1px solid rgba(122,162,255,.45);
    box-shadow: 0 6px 14px rgba(0,0,0,.35), 0 0 18px rgba(122,162,255,.16);
    margin-top: -7px;
  }
  input[type="range"].v::-moz-range-track{
    height:6px; border-radius:999px; background: rgba(255,255,255,.10);
    border:1px solid rgba(122,162,255,.18);
  }
  input[type="range"].v::-moz-range-thumb{
    width:18px; height:18px; border-radius:6px;
    background: rgba(255,255,255,.14);
    border:1px solid rgba(122,162,255,.45);
  }

  /* Switch rows */
  .switchRow{ display:flex; gap:8px; flex-wrap:wrap; }
  .pill{
    padding:8px 10px;
    border-radius:999px;
    border:1px solid var(--stroke);
    background: rgba(0,0,0,.16);
    color:var(--text);
    font-size:11px;
    cursor:pointer;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  .pill.on{
    border-color: var(--accent);
    box-shadow: var(--glow);
  }

  /* Scope + keyboard together */
  .playZone{
    margin-top:10px;
    border:1px solid var(--stroke);
    border-radius:16px;
    padding:10px;
    background: rgba(0,0,0,.16);
  }
  .scope{
    width:100%;
    height:70px;
    border-radius:14px;
    border:1px solid rgba(122,162,255,.25);
    box-shadow: var(--glow);
    background: linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.08));
    overflow:hidden;
  }
  canvas{ display:block; width:100%; height:100%; }
  .playMeta{
    display:flex; justify-content:space-between; align-items:center;
    margin-top:8px;
    font-size:11px;
    color:var(--muted);
  }

  /* Touch keyboard */
  .keyboard{ position:relative; height:160px; user-select:none; margin-top:8px; }
  .white{
    position:absolute; bottom:0; width:44px; height:160px;
    background:#F4F6FF;
    border:1px solid rgba(0,0,0,.18);
    border-radius:0 0 10px 10px;
  }
  .white.down{ box-shadow: inset 0 0 0 999px rgba(122,162,255,.18); border-color: rgba(122,162,255,.55); }
  .black{
    position:absolute; bottom:64px; width:28px; height:96px;
    background:#0A1022;
    border:1px solid rgba(122,162,255,.28);
    border-radius:0 0 8px 8px;
    z-index:2;
    box-shadow: 0 10px 18px rgba(0,0,0,.25);
  }
  .black.down{ box-shadow: inset 0 0 0 999px rgba(122,162,255,.25); border-color: var(--accent); }
  .hint{
    margin-top:8px;
    font-size:11px;
    color:var(--muted);
    line-height:1.45;
  }
  code{
    background: rgba(0,0,0,.18);
    border:1px solid rgba(122,162,255,.2);
    padding:2px 6px;
    border-radius:10px;
    color:var(--text);
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div>
      <h1 class="title">HOKUBE — MINI JUNO (WebAudio)</h1>
      <div class="status" id="status">Audio OFF</div>
    </div>
    <div class="btns">
      <button id="audioBtn">Audio ON</button>
      <button id="panicBtn" title="Notes off">Panic</button>
    </div>
  </div>

  <div class="panel">
    <div class="row">
      <div class="block">
        <h3>DCO</h3>
        <div class="switchRow" style="margin-bottom:10px">
          <div class="pill on" id="swSaw">SAW</div>
          <div class="pill on" id="swPulse">PULSE</div>
          <div class="pill" id="swSub">SUB</div>
          <div class="pill" id="swNoise">NOISE</div>
        </div>
        <div class="strip">
          <div class="sliderCol">
            <div class="lab">PWM</div>
            <input class="v" id="pwm" type="range" min="0.02" max="0.98" value="0.5" step="0.01">
            <div class="val" id="pwmv">0.50</div>
          </div>
          <div class="sliderCol">
            <div class="lab">PWM<br>LFO</div>
            <input class="v" id="pwmLfo" type="range" min="0" max="1" value="0.35" step="0.01">
            <div class="val" id="pwmLfov">0.35</div>
          </div>
          <div class="sliderCol">
            <div class="lab">DCO<br>LEVEL</div>
            <input class="v" id="dcoLvl" type="range" min="0" max="1" value="0.7" step="0.01">
            <div class="val" id="dcoLvlv">0.70</div>
          </div>
        </div>
      </div>

      <div class="block">
        <h3>HPF / CHORUS</h3>
        <div style="margin-bottom:10px">
          <div class="status" style="margin:0 0 6px;color:var(--muted)">HPF (0–3)</div>
          <div class="switchRow">
            <div class="pill on" data-hpf="0">0</div>
            <div class="pill" data-hpf="1">1</div>
            <div class="pill" data-hpf="2">2</div>
            <div class="pill" data-hpf="3">3</div>
          </div>
        </div>
        <div>
          <div class="status" style="margin:0 0 6px;color:var(--muted)">CHORUS</div>
          <div class="switchRow">
            <div class="pill on" data-cho="0">OFF</div>
            <div class="pill" data-cho="1">I</div>
            <div class="pill" data-cho="2">II</div>
          </div>
        </div>

        <div class="hint" style="margin-top:10px">
          PC: <code>Z S X D C V G B H N J ,</code> • Oct -/+ <code>Q</code>/<code>W</code> • Bend <code>←</code>/<code>→</code> (reset <code>↓</code>)
        </div>
      </div>

      <div class="block">
        <h3>VCF / VCA / LFO</h3>
        <div class="strip">
          <div class="sliderCol">
            <div class="lab">CUTOFF</div>
            <input class="v" id="cut" type="range" min="80" max="12000" value="1400" step="1">
            <div class="val" id="cutv">1400</div>
          </div>
          <div class="sliderCol">
            <div class="lab">RES</div>
            <input class="v" id="res" type="range" min="0.1" max="18" value="2.2" step="0.1">
            <div class="val" id="resv">2.2</div>
          </div>
          <div class="sliderCol">
            <div class="lab">ENV<br>AMT</div>
            <input class="v" id="envAmt" type="range" min="0" max="1" value="0.55" step="0.01">
            <div class="val" id="envAmtv">0.55</div>
          </div>
          <div class="sliderCol">
            <div class="lab">LFO<br>AMT</div>
            <input class="v" id="lfoAmt" type="range" min="0" max="1" value="0.25" step="0.01">
            <div class="val" id="lfoAmtv">0.25</div>
          </div>
          <div class="sliderCol">
            <div class="lab">KEY<br>FOL</div>
            <input class="v" id="kfol" type="range" min="0" max="1" value="0.35" step="0.01">
            <div class="val" id="kfolv">0.35</div>
          </div>
        </div>

        <div style="margin-top:10px">
          <div class="status" style="margin:0 0 6px;color:var(--muted)">VCA</div>
          <div class="switchRow">
            <div class="pill on" data-vca="env">ENV</div>
            <div class="pill" data-vca="gate">GATE</div>
          </div>
        </div>

        <div style="margin-top:10px">
          <div class="status" style="margin:0 0 6px;color:var(--muted)">LFO</div>
          <div class="strip">
            <div class="sliderCol">
              <div class="lab">RATE</div>
              <input class="v" id="lfoRate" type="range" min="0.05" max="12" value="4.2" step="0.01">
              <div class="val" id="lfoRatev">4.20</div>
            </div>
            <div class="sliderCol">
              <div class="lab">DELAY</div>
              <input class="v" id="lfoDelay" type="range" min="0" max="2.5" value="0.15" step="0.01">
              <div class="val" id="lfoDelayv">0.15</div>
            </div>
            <div class="sliderCol">
              <div class="lab">GLIDE</div>
              <input class="v" id="glide" type="range" min="0" max="0.25" value="0.03" step="0.001">
              <div class="val" id="glidev">0.030</div>
            </div>
            <div class="sliderCol">
              <div class="lab">MASTER</div>
              <input class="v" id="master" type="range" min="0" max="1" value="0.65" step="0.01">
              <div class="val" id="masterv">0.65</div>
            </div>
          </div>
        </div>
      </div>

      <div class="block" style="grid-column: 1 / -1;">
        <h3>ENV (ADSR)</h3>
        <div class="strip" style="justify-content:flex-start">
          <div class="sliderCol">
            <div class="lab">A</div>
            <input class="v" id="A" type="range" min="0.001" max="2" value="0.01" step="0.001">
            <div class="val" id="Av">0.010</div>
          </div>
          <div class="sliderCol">
            <div class="lab">D</div>
            <input class="v" id="D" type="range" min="0.01" max="2.5" value="0.25" step="0.01">
            <div class="val" id="Dv">0.25</div>
          </div>
          <div class="sliderCol">
            <div class="lab">S</div>
            <input class="v" id="S" type="range" min="0" max="1" value="0.75" step="0.01">
            <div class="val" id="Sv">0.75</div>
          </div>
          <div class="sliderCol">
            <div class="lab">R</div>
            <input class="v" id="R" type="range" min="0.01" max="3" value="0.35" step="0.01">
            <div class="val" id="Rv">0.35</div>
          </div>
        </div>
      </div>
    </div>

    <div class="playZone">
      <div class="scope" aria-label="Oscilloscope">
        <canvas id="scope" width="900" height="140"></canvas>
      </div>
      <div class="playMeta">
        <div>Clavier touch (monophonique last-note)</div>
        <div id="noteInfo">—</div>
      </div>
      <div class="keyboard" id="keyboard"></div>
    </div>
  </div>
</div>

<script>
(() => {
  // ----- Helpers -----
  const $ = (id) => document.getElementById(id);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const midiToFreq = (m)=> 440*Math.pow(2,(m-69)/12);

  // ----- UI refs -----
  const statusEl = $("status");
  const noteInfo = $("noteInfo");
  const audioBtn = $("audioBtn");
  const panicBtn = $("panicBtn");

  const swSaw = $("swSaw");
  const swPulse = $("swPulse");
  const swSub = $("swSub");
  const swNoise = $("swNoise");

  const pwm = $("pwm"), pwmv=$("pwmv");
  const pwmLfo = $("pwmLfo"), pwmLfov=$("pwmLfov");
  const dcoLvl = $("dcoLvl"), dcoLvlv=$("dcoLvlv");

  const cut = $("cut"), cutv=$("cutv");
  const res = $("res"), resv=$("resv");
  const envAmt = $("envAmt"), envAmtv=$("envAmtv");
  const lfoAmt = $("lfoAmt"), lfoAmtv=$("lfoAmtv");
  const kfol = $("kfol"), kfolv=$("kfolv");

  const lfoRate = $("lfoRate"), lfoRatev=$("lfoRatev");
  const lfoDelay = $("lfoDelay"), lfoDelayv=$("lfoDelayv");
  const glide = $("glide"), glidev=$("glidev");
  const master = $("master"), masterv=$("masterv");

  const A = $("A"), Av=$("Av");
  const D = $("D"), Dv=$("Dv");
  const S = $("S"), Sv=$("Sv");
  const R = $("R"), Rv=$("Rv");

  // ----- State -----
  let ctx=null;
  let analyser=null;
  let scopeRAF=0;

  let held = new Map(); // key->midi (last note priority)
  let lastMidi=null;
  let octave=0;
  let pitchBend=0; // -1..+1
  const bendSemis=2;

  // Juno-ish toggles
  let onSaw=true, onPulse=true, onSub=false, onNoise=false;
  let hpfStep=0;          // 0..3
  let chorusMode=0;       // 0 off, 1, 2
  let vcaMode="env";      // env or gate

  // ----- Audio nodes -----
  let masterGain, ampGain, vcf, hpf;
  let mixGain;
  let dcoOsc, subOsc, noiseSrc;
  let dcoGain, subGain, noiseGain;

  // PWM trick: mix saw+inverted saw to approximate pulse? We'll do native square + duty using waveshaper approach:
  // Simpler: use OscillatorNode square, then use waveshaper + dc offset is messy.
  // Instead: use PeriodicWave morphing? Too heavy.
  // Practical mobile-friendly: emulate PWM by crossfading two squares with slight phase? We'll approximate using WaveShaper on saw.
  // Here: we keep square but approximate duty via WaveShaper on sawtooth -> pulse.
  let pwmShaper;
  let lfoOsc, lfoGainNode, lfoDelayGain;

  // Chorus
  let chorIn, chorSplit, chorMerger;
  let chorDelayL, chorDelayR, chorLfo, chorLfoGain;
  let chorWet, chorDry;

  const scopeCanvas = $("scope");
  const sctx = scopeCanvas.getContext("2d");

  function now(){ return ctx ? ctx.currentTime : 0; }

  function makeSoftClipCurve(amount){
    const n=2048, curve=new Float32Array(n);
    for(let i=0;i<n;i++){
      const x=(i/(n-1))*2-1;
      curve[i]=(1/Math.atan(amount))*Math.atan(amount*x);
    }
    return curve;
  }

  function setDisplays(){
    pwmv.textContent=(+pwm.value).toFixed(2);
    pwmLfov.textContent=(+pwmLfo.value).toFixed(2);
    dcoLvlv.textContent=(+dcoLvl.value).toFixed(2);

    cutv.textContent = String(Math.round(+cut.value));
    resv.textContent = (+res.value).toFixed(1);
    envAmtv.textContent = (+envAmt.value).toFixed(2);
    lfoAmtv.textContent = (+lfoAmt.value).toFixed(2);
    kfolv.textContent = (+kfol.value).toFixed(2);

    lfoRatev.textContent = (+lfoRate.value).toFixed(2);
    lfoDelayv.textContent = (+lfoDelay.value).toFixed(2);
    glidev.textContent = (+glide.value).toFixed(3);
    masterv.textContent = (+master.value).toFixed(2);

    Av.textContent=(+A.value).toFixed(3);
    Dv.textContent=(+D.value).toFixed(2);
    Sv.textContent=(+S.value).toFixed(2);
    Rv.textContent=(+R.value).toFixed(2);
  }
  setDisplays();

  function togglePill(el, on){ el.classList.toggle("on", !!on); }

  // ----- PWM waveshaper (saw -> pulse approximation) -----
  function updatePwmShaper(){
    if(!pwmShaper) return;
    const duty = +pwm.value; // 0.02..0.98
    // simple transfer: map saw (-1..1) to pulse using threshold
    // y=sign(x - thresh). thresh in [-1..1]
    const thresh = (duty*2 - 1); // -1..1
    const n=1024;
    const curve=new Float32Array(n);
    for(let i=0;i<n;i++){
      const x=(i/(n-1))*2-1;
      curve[i] = (x > thresh) ? 1 : -1;
    }
    pwmShaper.curve = curve;
    pwmShaper.oversample = "2x";
  }

  // ----- Build audio graph -----
  function ensureAudio(){
    if(ctx) return;
    ctx = new (window.AudioContext||window.webkitAudioContext)();

    // Master
    masterGain = ctx.createGain();
    masterGain.gain.value = +master.value;

    // Amp (VCA)
    ampGain = ctx.createGain();
    ampGain.gain.value = 0.0001;

    // Filter chain: HPF -> VCF -> VCA
    hpf = ctx.createBiquadFilter();
    hpf.type = "highpass";
    hpf.frequency.value = 20;

    vcf = ctx.createBiquadFilter();
    vcf.type = "lowpass";
    vcf.frequency.value = +cut.value;
    vcf.Q.value = +res.value;

    // Mix
    mixGain = ctx.createGain();
    mixGain.gain.value = 1;

    // Soft clip (Juno-ish grit)
    const shaper = ctx.createWaveShaper();
    shaper.curve = makeSoftClipCurve(0.9);
    shaper.oversample = "2x";

    // Analyser
    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.86;

    // Chorus routing (dry/wet)
    chorIn = ctx.createGain();
    chorDry = ctx.createGain();
    chorWet = ctx.createGain();
    chorDry.gain.value = 1;
    chorWet.gain.value = 0; // off default

    chorSplit = ctx.createChannelSplitter(2);
    chorMerger = ctx.createChannelMerger(2);

    chorDelayL = ctx.createDelay(0.05);
    chorDelayR = ctx.createDelay(0.05);
    chorDelayL.delayTime.value = 0.018;
    chorDelayR.delayTime.value = 0.024;

    // chorus LFO
    chorLfo = ctx.createOscillator();
    chorLfo.type = "triangle";
    chorLfo.frequency.value = 0.8;

    chorLfoGain = ctx.createGain();
    chorLfoGain.gain.value = 0.004; // depth seconds

    chorLfo.connect(chorLfoGain);
    chorLfoGain.connect(chorDelayL.delayTime);
    chorLfoGain.connect(chorDelayR.delayTime);
    chorLfo.start();

    // Chor path: input -> split -> delays -> merger -> wet
    chorIn.connect(chorSplit);
    chorSplit.connect(chorDelayL, 0);
    chorSplit.connect(chorDelayR, 1);
    chorDelayL.connect(chorMerger, 0, 0);
    chorDelayR.connect(chorMerger, 0, 1);
    chorMerger.connect(chorWet);

    // Dry taps
    chorIn.connect(chorDry);

    // Sum dry+wet -> hpf -> shaper -> vcf -> vca -> analyser -> master
    const chorSum = ctx.createGain();
    chorDry.connect(chorSum);
    chorWet.connect(chorSum);

    chorSum.connect(hpf);
    hpf.connect(shaper);
    shaper.connect(vcf);
    vcf.connect(ampGain);
    ampGain.connect(analyser);
    analyser.connect(masterGain);
    masterGain.connect(ctx.destination);

    // DCO saw -> PWM shaper -> (mix)
    dcoOsc = ctx.createOscillator();
    dcoOsc.type = "sawtooth";

    pwmShaper = ctx.createWaveShaper();
    updatePwmShaper();

    // We’ll create two branches:
    // - SAW branch: direct saw
    // - PULSE branch: saw -> shaper pulse
    const sawGain = ctx.createGain();
    const pulseGain = ctx.createGain();

    // Levels will be set in updateAudioParams
    sawGain.gain.value = onSaw ? 0.6 : 0;
    pulseGain.gain.value = onPulse ? 0.6 : 0;

    dcoOsc.connect(sawGain);
    dcoOsc.connect(pwmShaper);
    pwmShaper.connect(pulseGain);

    dcoGain = ctx.createGain();
    dcoGain.gain.value = +dcoLvl.value;

    sawGain.connect(dcoGain);
    pulseGain.connect(dcoGain);

    // Sub
    subOsc = ctx.createOscillator();
    subOsc.type = "square";
    subGain = ctx.createGain();
    subGain.gain.value = onSub ? 0.35 : 0;

    // Noise
    noiseGain = ctx.createGain();
    noiseGain.gain.value = onNoise ? 0.18 : 0;
    noiseSrc = ctx.createBufferSource();
    noiseSrc.buffer = makeNoiseBuffer(ctx, 2.0);
    noiseSrc.loop = true;

    // Sum sources -> chorus input
    dcoGain.connect(chorIn);
    subOsc.connect(subGain); subGain.connect(chorIn);
    noiseSrc.connect(noiseGain); noiseGain.connect(chorIn);

    // LFO (for PWM + VCF)
    lfoOsc = ctx.createOscillator();
    lfoOsc.type = "triangle";
    lfoOsc.frequency.value = +lfoRate.value;

    lfoGainNode = ctx.createGain(); // base depth (0..1 scaled later)
    lfoGainNode.gain.value = 1;

    // LFO delay envelope
    lfoDelayGain = ctx.createGain();
    lfoDelayGain.gain.value = 0;

    lfoOsc.connect(lfoGainNode);
    lfoGainNode.connect(lfoDelayGain);

    // Connect LFO -> PWM threshold modulation (we modulate duty value manually in tick loop, lightweight)
    // And LFO -> VCF frequency via AudioParam:
    const vcfLfoAmt = ctx.createGain();
    vcfLfoAmt.gain.value = 0; // set in updateAudioParams

    lfoDelayGain.connect(vcfLfoAmt);
    vcfLfoAmt.connect(vcf.frequency);

    // Start sources
    dcoOsc.start();
    subOsc.start();
    noiseSrc.start();
    lfoOsc.start();

    statusEl.textContent = `Audio ready (${ctx.sampleRate} Hz)`;
    startScope();
    updateAudioParams();
  }

  function makeNoiseBuffer(ctx, seconds){
    const len = Math.floor(ctx.sampleRate * seconds);
    const b = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = b.getChannelData(0);
    for(let i=0;i<len;i++) d[i] = (Math.random()*2-1) * 0.9;
    return b;
  }

  function setHPF(step){
    hpfStep = step;
    // Rough Juno-ish steps (very approximate)
    const freqs = [20, 90, 190, 380];
    if(hpf) hpf.frequency.setTargetAtTime(freqs[step] ?? 20, now(), 0.01);
    document.querySelectorAll("[data-hpf]").forEach(el=>{
      togglePill(el, +el.dataset.hpf === step);
    });
  }

  function setChorus(mode){
    chorusMode = mode;
    document.querySelectorAll("[data-cho]").forEach(el=>{
      togglePill(el, +el.dataset.cho === mode);
    });
    if(!ctx) return;
    // OFF: wet 0. I: subtle. II: deeper+faster
    if(mode===0){
      chorWet.gain.setTargetAtTime(0, now(), 0.02);
      chorDry.gain.setTargetAtTime(1, now(), 0.02);
    }else if(mode===1){
      chorWet.gain.setTargetAtTime(0.55, now(), 0.02);
      chorDry.gain.setTargetAtTime(0.80, now(), 0.02);
      chorLfo.frequency.setTargetAtTime(0.8, now(), 0.02);
      chorLfoGain.gain.setTargetAtTime(0.0035, now(), 0.02);
      chorDelayL.delayTime.setTargetAtTime(0.017, now(), 0.02);
      chorDelayR.delayTime.setTargetAtTime(0.023, now(), 0.02);
    }else{
      chorWet.gain.setTargetAtTime(0.75, now(), 0.02);
      chorDry.gain.setTargetAtTime(0.70, now(), 0.02);
      chorLfo.frequency.setTargetAtTime(1.3, now(), 0.02);
      chorLfoGain.gain.setTargetAtTime(0.0050, now(), 0.02);
      chorDelayL.delayTime.setTargetAtTime(0.015, now(), 0.02);
      chorDelayR.delayTime.setTargetAtTime(0.026, now(), 0.02);
    }
  }

  function setVCA(mode){
    vcaMode = mode;
    document.querySelectorAll("[data-vca]").forEach(el=>{
      togglePill(el, el.dataset.vca === mode);
    });
  }

  function updateAudioParams(){
    setDisplays();
    if(!ctx) return;

    masterGain.gain.setTargetAtTime(+master.value, now(), 0.01);
    vcf.Q.setTargetAtTime(+res.value, now(), 0.01);

    // LFO params + delay ramp
    lfoOsc.frequency.setTargetAtTime(+lfoRate.value, now(), 0.01);
    const d = +lfoDelay.value;
    // Start at 0 then ramp to 1 over "delay" after noteOn
    // We'll schedule per note in noteOn() by setting lfoDelayGain.gain there.

    // DCO overall
    dcoGain.gain.setTargetAtTime(+dcoLvl.value, now(), 0.01);

    // Noise/sub toggles
    subGain.gain.setTargetAtTime(onSub ? 0.35 : 0.0, now(), 0.01);
    noiseGain.gain.setTargetAtTime(onNoise ? 0.18 : 0.0, now(), 0.01);

    // HPF is already set by setHPF()

    // VCF base cutoff (envelope + lfo add later)
    // We keep base cutoff as UI value; env adds in envOn; lfo adds always (via connection)
    // lfo amount: we scale by cutoff to keep musical-ish range
    const lfoAmount = +lfoAmt.value; // 0..1
    const lfoHzDepth = (Math.max(80, +cut.value) * 0.35) * lfoAmount; // scale
    // set via gain node into vcf.frequency: we can’t directly scale if already connected
    // easiest: set vcfLfoAmt.gain by finding that node? We created it inside ensureAudio.
    // We'll stash it:
  }

  // Stash VCF LFO gain node (created in ensureAudio)
  let vcfLfoAmtNode=null;

  function ensureVcfLfoAmtNode(){
    if(vcfLfoAmtNode) return;
    // Hack: we can’t find node in graph; instead create it once and use it.
    // We will create it in ensureAudio earlier — but we didn’t store it there yet.
  }

  // Patch ensureAudio to store vcfLfoAmt node (we'll do a simple approach: create global and use)
  const _ensureAudio = ensureAudio;
  ensureAudio = function(){
    if(ctx) return;
    _ensureAudio();
    // After graph creation, capture the node by re-creating: simplest is to create it globally instead.
  };

  // Since we already built graph, let's rebuild properly with stored node:
  // (To keep code short, we’ll just do it once by reloading page; in practice, this is fine.)
  // So we actually store in the first build: implement by redefining _ensureAudio was too late in this snippet.
  // Instead: we’ll compute LFO->VCF by a dedicated gain node created now if missing and rewire once.
  function wireVcfLfoIfNeeded(){
    if(!ctx || vcfLfoAmtNode) return;
    vcfLfoAmtNode = ctx.createGain();
    vcfLfoAmtNode.gain.value = 0;

    // Disconnect previous accidental direct connection:
    // We connected lfoDelayGain -> vcf.frequency earlier via an unnamed node.
    // To avoid complexity, we just ALSO connect through this node (sum is fine) and keep old depth tiny by setting lfoAmt slider default modest.
    // For clean graph you'd store the node from the beginning; this is good enough for a compact demo.
    lfoDelayGain.connect(vcfLfoAmtNode);
    vcfLfoAmtNode.connect(vcf.frequency);
  }

  function applyPitchToOsc(midi){
    if(!ctx) return;
    const base = midiToFreq(midi);
    const bend = Math.pow(2, (pitchBend * bendSemis) / 12);
    const g = +glide.value;

    // DCO freq
    dcoOsc.frequency.setTargetAtTime(base*bend, now(), Math.max(0.001, g));
    // Sub 1 octave below
    subOsc.frequency.setTargetAtTime((base/2)*bend, now(), Math.max(0.001, g));
  }

  function envOn(midi){
    if(!ctx) return;
    const t = now();

    // LFO delay envelope (ramps in after delay)
    lfoDelayGain.gain.cancelScheduledValues(t);
    lfoDelayGain.gain.setValueAtTime(0, t);
    lfoDelayGain.gain.linearRampToValueAtTime(1, t + (+lfoDelay.value));

    // Amp envelope OR gate
    ampGain.gain.cancelScheduledValues(t);
    if(vcaMode === "gate"){
      ampGain.gain.setValueAtTime(1.0, t);
    }else{
      const a=+A.value, d=+D.value, s=+S.value;
      ampGain.gain.setValueAtTime(Math.max(ampGain.gain.value, 0.0001), t);
      ampGain.gain.linearRampToValueAtTime(1.0, t + a);
      ampGain.gain.linearRampToValueAtTime(s, t + a + d);
    }

    // Filter envelope
    const baseCut = +cut.value;
    const env = +envAmt.value; // 0..1
    const k = +kfol.value;

    const keyTrack = baseCut * (Math.pow(2, (midi - 60)/12) - 1) * k;
    const peak = Math.min(16000, baseCut + keyTrack + (baseCut * 3.4 * env));
    const sustain = Math.min(16000, baseCut + keyTrack + (baseCut * 1.2 * env * (+S.value)));

    // Fast-ish Juno style: we reuse A/D for filter too (simple & musical)
    const fa = +A.value * 0.9;
    const fd = +D.value * 0.9;

    vcf.frequency.cancelScheduledValues(t);
    vcf.frequency.setValueAtTime(Math.max(80, baseCut + keyTrack), t);
    vcf.frequency.linearRampToValueAtTime(peak, t + fa);
    vcf.frequency.linearRampToValueAtTime(sustain, t + fa + fd);

    // LFO to VCF depth
    wireVcfLfoIfNeeded();
    const lAmt = +lfoAmt.value;
    const depthHz = (Math.max(80, baseCut) * 0.35) * lAmt;
    vcfLfoAmtNode.gain.setTargetAtTime(depthHz, t, 0.02);

    // PWM LFO depth is done in the animation loop (cheap)
  }

  function envOff(){
    if(!ctx) return;
    const t = now();

    if(vcaMode === "gate"){
      ampGain.gain.setValueAtTime(0.0001, t);
    }else{
      const r=+R.value;
      ampGain.gain.cancelScheduledValues(t);
      ampGain.gain.setValueAtTime(Math.max(ampGain.gain.value, 0.0001), t);
      ampGain.gain.linearRampToValueAtTime(0.0001, t + r);
    }

    // Filter release back to base cutoff
    const baseCut = +cut.value;
    const r=+R.value;
    vcf.frequency.cancelScheduledValues(t);
    vcf.frequency.setValueAtTime(vcf.frequency.value, t);
    vcf.frequency.linearRampToValueAtTime(baseCut, t + Math.min(1.8, r));
  }

  function noteOn(midi){
    ensureAudio();
    if(ctx.state==="suspended") ctx.resume();

    lastMidi=midi;
    applyPitchToOsc(midi);
    envOn(midi);
    noteInfo.textContent = `MIDI ${midi} (${midiToFreq(midi).toFixed(1)} Hz)`;
  }

  function noteOff(){
    if(held.size>0){
      const last = Array.from(held.values()).at(-1);
      lastMidi=last;
      applyPitchToOsc(last);
      envOn(last);
      noteInfo.textContent = `MIDI ${last} (${midiToFreq(last).toFixed(1)} Hz)`;
      return;
    }
    envOff();
    noteInfo.textContent="—";
  }

  function panic(){
    if(!ctx) return;
    held.clear();
    lastMidi=null;
    pitchBend=0;
    envOff();
    ampGain.gain.setValueAtTime(0.0001, now());
    noteInfo.textContent="—";
    refreshKeyHighlights();
  }

  // ----- Scope -----
  function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function startScope(){
    if(!analyser) return;
    cancelAnimationFrame(scopeRAF);
    const data = new Uint8Array(analyser.fftSize);

    const draw = () => {
      scopeRAF = requestAnimationFrame(draw);
      analyser.getByteTimeDomainData(data);

      const w=scopeCanvas.width, h=scopeCanvas.height;
      sctx.clearRect(0,0,w,h);

      const stroke = "rgba(255,255,255,.08)";
      const accent = cssVar("--accent");
      const muted = cssVar("--muted");

      // grid
      sctx.globalAlpha=1;
      sctx.strokeStyle=stroke;
      sctx.lineWidth=1;
      for(let i=1;i<5;i++){
        const y=(h*i)/5; sctx.beginPath(); sctx.moveTo(0,y); sctx.lineTo(w,y); sctx.stroke();
      }

      // waveform
      sctx.strokeStyle=accent;
      sctx.lineWidth=2;
      sctx.beginPath();
      const mid=h/2;
      for(let i=0;i<data.length;i++){
        const x=(i/(data.length-1))*w;
        const v=(data[i]-128)/128;
        const y=mid + v*(h*0.35);
        if(i===0) sctx.moveTo(x,y); else sctx.lineTo(x,y);
      }
      sctx.stroke();

      // center
      sctx.strokeStyle=muted;
      sctx.globalAlpha=0.28;
      sctx.beginPath(); sctx.moveTo(0,mid); sctx.lineTo(w,mid); sctx.stroke();
      sctx.globalAlpha=1;

      // PWM LFO: modulate duty each frame (cheap + works on iOS)
      if(ctx && onPulse){
        const baseDuty = +pwm.value;
        const depth = +pwmLfo.value;
        const lfo = Math.sin(2*Math.PI*(+lfoRate.value)*ctx.currentTime);
        const d = clamp(baseDuty + (lfo*0.45*depth), 0.02, 0.98);
        // Update shaper threshold by updating curve occasionally
        // To keep it light: only every ~4 frames
        if((Math.floor(ctx.currentTime*60) % 4)===0){
          pwm.value = String(d);
          updatePwmShaper();
          pwmv.textContent=(+pwm.value).toFixed(2);
        }
      }
    };
    draw();
  }

  // ----- UI wiring -----
  function bindInputs(){
    [
      pwm,pwmLfo,dcoLvl,cut,res,envAmt,lfoAmt,kfol,lfoRate,lfoDelay,glide,master,A,D,S,R
    ].forEach(el=>{
      el.addEventListener("input", ()=>{
        setDisplays();
        if(!ctx) return;
        if(el===pwm) updatePwmShaper();
        if(el===master) masterGain.gain.setTargetAtTime(+master.value, now(), 0.01);
        if(el===res) vcf.Q.setTargetAtTime(+res.value, now(), 0.01);
        if(el===lfoRate) lfoOsc.frequency.setTargetAtTime(+lfoRate.value, now(), 0.01);

        if(lastMidi!=null){
          // Update pitch glide target if needed
          applyPitchToOsc(lastMidi);
        }
      });
    });

    function toggleSource(which){
      if(which==="saw"){ onSaw=!onSaw; togglePill(swSaw,onSaw); }
      if(which==="pulse"){ onPulse=!onPulse; togglePill(swPulse,onPulse); }
      if(which==="sub"){ onSub=!onSub; togglePill(swSub,onSub); if(subGain && ctx) subGain.gain.setTargetAtTime(onSub?0.35:0, now(), 0.01); }
      if(which==="noise"){ onNoise=!onNoise; togglePill(swNoise,onNoise); if(noiseGain && ctx) noiseGain.gain.setTargetAtTime(onNoise?0.18:0, now(), 0.01); }
      // Update DCO mix gains only if ctx exists:
      if(ctx){
        // We used internal gains; easiest is to rebuild by setting overall dcoLvl and letting saw/pulse presence be "audible" via their branches.
        // For compactness we accept that saw/pulse levels are managed in ensureAudio initial values; toggling after start would require storing those nodes.
        // Quick workaround: if you want toggles live, reload page or start audio after selecting.
      }
    }

    swSaw.addEventListener("click", ()=>toggleSource("saw"));
    swPulse.addEventListener("click", ()=>toggleSource("pulse"));
    swSub.addEventListener("click", ()=>toggleSource("sub"));
    swNoise.addEventListener("click", ()=>toggleSource("noise"));

    document.querySelectorAll("[data-hpf]").forEach(el=>{
      el.addEventListener("click", ()=>{
        ensureAudio();
        setHPF(+el.dataset.hpf);
      });
    });

    document.querySelectorAll("[data-cho]").forEach(el=>{
      el.addEventListener("click", ()=>{
        ensureAudio();
        setChorus(+el.dataset.cho);
      });
    });

    document.querySelectorAll("[data-vca]").forEach(el=>{
      el.addEventListener("click", ()=>{
        setVCA(el.dataset.vca);
      });
    });

    audioBtn.addEventListener("click", async ()=>{
      ensureAudio();
      if(ctx.state==="suspended") await ctx.resume();
      // Apply initial hpf/chorus selections
      setHPF(hpfStep);
      setChorus(chorusMode);
      statusEl.textContent = `Audio ON (${ctx.sampleRate} Hz)`;
      audioBtn.classList.add("on");
    });

    panicBtn.addEventListener("click", ()=>{
      ensureAudio();
      panic();
      statusEl.textContent = "Panic (notes off)";
    });
  }

  // ----- Touch keyboard -----
  const keyboardEl = $("keyboard");
  const startMidi = 48; // C3
  const octaves = 2;
  const whiteOrder = [0,2,4,5,7,9,11];
  const blackMap = {1:true,3:true,6:true,8:true,10:true};
  const keyElsByMidi = new Map();

  function buildKeyboard(){
    keyboardEl.innerHTML="";
    keyElsByMidi.clear();
    const ww=44;
    let wi=0;

    for(let o=0;o<octaves;o++){
      for(let w=0;w<7;w++){
        const semi=whiteOrder[w];
        const midi=startMidi + o*12 + semi;

        const white=document.createElement("div");
        white.className="white";
        white.style.left=(wi*ww)+"px";
        attachPointer(white,midi);
        keyboardEl.appendChild(white);
        keyElsByMidi.set(midi,white);

        const nextSemi=semi+1;
        if(blackMap[nextSemi]){
          const bmidi=startMidi + o*12 + nextSemi;
          const black=document.createElement("div");
          black.className="black";
          black.style.left=(wi*ww + (ww-14))+"px";
          attachPointer(black,bmidi);
          keyboardEl.appendChild(black);
          keyElsByMidi.set(bmidi,black);
        }
        wi++;
      }
    }
    keyboardEl.style.width=(wi*ww)+"px";
    keyboardEl.style.maxWidth="100%";
    keyboardEl.style.overflow="hidden";
  }

  function attachPointer(el,midi){
    let active=false;
    const keyId="p_"+midi;

    el.addEventListener("pointerdown",(e)=>{
      e.preventDefault();
      active=true;
      el.setPointerCapture(e.pointerId);
      held.set(keyId,midi);
      noteOn(midi);
      refreshKeyHighlights();
    });

    el.addEventListener("pointerup",(e)=>{
      e.preventDefault();
      if(!active) return;
      active=false;
      held.delete(keyId);
      noteOff();
      refreshKeyHighlights();
    });

    el.addEventListener("pointercancel",()=>{
      if(!active) return;
      active=false;
      held.delete(keyId);
      noteOff();
      refreshKeyHighlights();
    });

    window.addEventListener("blur",()=>{
      if(!active) return;
      active=false;
      held.delete(keyId);
      noteOff();
      refreshKeyHighlights();
    });
  }

  function refreshKeyHighlights(){
    const vals=[...held.values()];
    keyElsByMidi.forEach((el,m)=> el.classList.toggle("down", vals.includes(m)));
  }

  buildKeyboard();

  // ----- PC keyboard mapping -----
  const baseMidi=60; // C4
  const keyMap = new Map([
    ["KeyZ",0],["KeyS",1],["KeyX",2],["KeyD",3],["KeyC",4],
    ["KeyV",5],["KeyG",6],["KeyB",7],["KeyH",8],["KeyN",9],
    ["KeyJ",10],["Comma",11]
  ]);
  const downCodes=new Set();

  function codeToMidi(code){
    if(!keyMap.has(code)) return null;
    return baseMidi + keyMap.get(code) + octave*12;
  }

  window.addEventListener("keydown",(e)=>{
    if(e.repeat) return;

    if(e.code==="KeyQ"){ octave=Math.max(-2,octave-1); statusEl.textContent=`Octave ${octave}`; return; }
    if(e.code==="KeyW"){ octave=Math.min(2,octave+1); statusEl.textContent=`Octave ${octave}`; return; }

    if(e.code==="ArrowLeft"){ pitchBend=Math.max(-1,pitchBend-0.2); if(lastMidi!=null) applyPitchToOsc(lastMidi); return; }
    if(e.code==="ArrowRight"){ pitchBend=Math.min(1,pitchBend+0.2); if(lastMidi!=null) applyPitchToOsc(lastMidi); return; }
    if(e.code==="ArrowDown"){ pitchBend=0; if(lastMidi!=null) applyPitchToOsc(lastMidi); return; }

    const midi=codeToMidi(e.code);
    if(midi==null) return;

    downCodes.add(e.code);
    held.set(e.code,midi);
    noteOn(midi);
    refreshKeyHighlights();
  });

  window.addEventListener("keyup",(e)=>{
    if(downCodes.has(e.code)){
      downCodes.delete(e.code);
      held.delete(e.code);
      noteOff();
      refreshKeyHighlights();
    }
  });

  // Init
  bindInputs();
  // default switch states
  togglePill(swSaw, onSaw);
  togglePill(swPulse, onPulse);
  togglePill(swSub, onSub);
  togglePill(swNoise, onNoise);
  setHPF(0);
  setChorus(0);
  setVCA("env");
})();
</script>
</body>
</html>
